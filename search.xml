<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java类的初始化过程</title>
    <url>/2020/05/05/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<br>
<br>
<br>

<p><a name="atHd5"></a></p>
<h3 id="类的整个生命周期过程"><a href="#类的整个生命周期过程" class="headerlink" title="类的整个生命周期过程"></a>类的整个生命周期过程</h3><ul>
<li>加载</li>
<li>连接<ul>
<li>校验</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p><img src="/2020/05/05/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/linkage.png" alt="image.png"></p>
<br>
<br>

<p><a name="E8x6j"></a></p>
<h3 id="类创建过程主要分两步骤"><a href="#类创建过程主要分两步骤" class="headerlink" title="类创建过程主要分两步骤"></a>类创建过程主要分两步骤</h3><ul>
<li>类的加载过程, 本质上是在方法区生成类的Class对象，共其他地方引用使用</li>
<li>类的实例化</li>
</ul>
<p><a name="l282i"></a></p>
<h4 id="次序"><a href="#次序" class="headerlink" title="次序"></a>次序</h4><ul>
<li>次序是: 先自己的变量-&gt;父类-&gt;初始化</li>
<li>接口跟类不一样，接口只有在使用到的时候才会去初始化，而类即使没有使用到也会在它的子类初始化的时候被初始化出来</li>
</ul>
<p><a name="k5GKh"></a></p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>加载过程主要是对class的加载，不包含实例的初始化过程，所以操作的内存区域是方法区，这个过程主要包括：</p>
<ul>
<li>加载，将字节码文件加载到内存中来(比如从jar包中加载，从URL中加载)</li>
<li>连接(link)<ul>
<li>校验(verify): 校验字节码是否符合规范，比如<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>major/minor version是否是当前JVM支持的</li>
</ul>
</li>
<li>准备(prepare)，该阶段主要是给class的初始化做内存准备(静态变量)，比如<ul>
<li>为类变量(非实例变量)分配内存</li>
<li>为类变量赋予零值，比如int会给个0</li>
<li>对于final的类变量，这个阶段会直接给变量赋值而不是给初始值</li>
</ul>
</li>
<li>解析(resolve)，该阶段主要是解析该类引用的其他类，并将它们加载进来</li>
</ul>
</li>
<li>初始化<ul>
<li>对静态变量进行初始化</li>
<li>这个阶段会初始化静态变量和调用静态代码块</li>
<li>他们之间谁先谁后，取决于他们在源码中的先后顺序</li>
</ul>
</li>
</ul>
<br>

<p><a name="izS7T"></a></p>
<h4 id="实例的初始化过程"><a href="#实例的初始化过程" class="headerlink" title="实例的初始化过程"></a>实例的初始化过程</h4><ul>
<li>为实例变量分配内存，主要是堆中</li>
<li>给实例变量分配初始值</li>
<li>实例化父类</li>
<li>给实例变量赋予源码中的值, 调用实例块 (他们的先后顺序取决于他们在源码中的位置)</li>
<li>执行构造方法中剩余的代码</li>
</ul>
<br>

<p><a name="Yqlqk"></a></p>
<h3 id="实例创建的整个过程"><a href="#实例创建的整个过程" class="headerlink" title="实例创建的整个过程"></a>实例创建的整个过程</h3><p><img src="/2020/05/05/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/process.svg" alt="类的初始化guocheng.svg"><br><br><br><br><br></p>
<p><a name="GYm9T"></a></p>
<h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p><a name="R8DyH"></a></p>
<h4 id="1-被动引用不会触发初始化"><a href="#1-被动引用不会触发初始化" class="headerlink" title="1. 被动引用不会触发初始化"></a>1. 被动引用不会触发初始化</h4><p>被动加载是相对主动加载来说的，主动加载是Java虚拟机规范中定义的几种类型:</p>
<ul>
<li>通过new/getstatic/putstatic/invokestatic指令触发的初始化</li>
<li>通过反射调用类的方法触发的初始化</li>
<li>在加载子类的时候，发现父类没有加载而触发的父类加载</li>
<li>调用类的main方法导致该类的初始化</li>
</ul>
<p><a name="iGhLB"></a></p>
<h5 id="1-1-通过子类引用父类的静态变量，不会导致子类的初始化"><a href="#1-1-通过子类引用父类的静态变量，不会导致子类的初始化" class="headerlink" title="1.1 通过子类引用父类的静态变量，不会导致子类的初始化"></a>1.1 通过子类引用父类的静态变量，不会导致子类的初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static block"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitializingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>以上代码只会初始化ParentClass，不会初始化SubClass. 输出的结果:<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parent Class static block</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<br>
<br>

<p><a name="X2MeK"></a></p>
<h5 id="1-2-通过数组定义来引用类，不会触发类的初始化"><a href="#1-2-通过数组定义来引用类，不会触发类的初始化" class="headerlink" title="1.2 通过数组定义来引用类，不会触发类的初始化"></a>1.2 通过数组定义来引用类，不会触发类的初始化</h5><p>数组的生成其实并没有生成数组元素的类，生成的是数组类, 比如 “[java.lang.Integer” 这样的类.<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static block"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitializingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SubClass[] subClasses = <span class="keyword">new</span> SubClass[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>运行之后发现，什么也没有输出，说明<code>SubClass[] subClasses = new SubClass[1];</code>跟 SubClass没有关系<br></p>
<p><a name="tcfKs"></a></p>
<h5 id="1-3-引用常量不会触发定义常量的类的初始化"><a href="#1-3-引用常量不会触发定义常量的类的初始化" class="headerlink" title="1.3 引用常量不会触发定义常量的类的初始化"></a>1.3 引用常量不会触发定义常量的类的初始化</h5><p>常量是只那些 final static的变量，这些变量会在准备阶段就初始化好，然后就会进入常量池里，之后其实就跟它所在的类没什么关系了. 后面其他类引用它的时候其实是从常量池中获取的.<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"constant class init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"kobe"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitializingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(ConstantClass.DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a name="sA9wT"></a></p>
<h3 id="2-父子类中override方法的执行"><a href="#2-父子类中override方法的执行" class="headerlink" title="2. 父子类中override方法的执行"></a>2. 父子类中override方法的执行</h3><p>当子类override了父类的方法的时候，在构造子类的实例阶段，父类调用的是子类的方法<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printThree();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"three"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> three = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(three);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">        subClass.printThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>输出的结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">SubClass Constructor</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这是因为在父类构造的时候，调用的是子类的printThree()，而此时three=0<br><br><br></p>
<p><a name="jVwYo"></a></p>
<h4 id="一个完整的实例构造例子"><a href="#一个完整的实例构造例子" class="headerlink" title="一个完整的实例构造例子"></a>一个完整的实例构造例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class instance block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> k = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printThree();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"three"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticBefore = staticP(<span class="string">"before"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticAfter = staticP(<span class="string">"after"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String instanceBefore = initK(<span class="string">"before"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass instance block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String instanceAfter = initK(<span class="string">"after"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> three = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticP</span><span class="params">(String i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static param: "</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubClass() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">initK</span><span class="params">(String j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"instance param:"</span> + j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(three);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line">        subClass.printThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>输出的结果<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parent Class static block</span><br><span class="line">static param: before</span><br><span class="line">SubClass static block</span><br><span class="line">static param: after</span><br><span class="line">Parent Class instance block</span><br><span class="line">0</span><br><span class="line">instance param:before</span><br><span class="line">SubClass instance block</span><br><span class="line">instance param:after</span><br><span class="line">SubClass Constructor</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS认证过程</title>
    <url>/2020/05/19/HTTPS%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><p>以下两篇文章对HTTPS解析的很详细，有图有真相，很好理解:</p>
<ul>
<li><a href="https://www.cnblogs.com/snowater/p/7804889.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowater/p/7804889.html</a></li>
<li><a href="https://www.cnblogs.com/xdyixia/p/11610102.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdyixia/p/11610102.html</a></li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>HTTPS是在HTTP跟TCP之间加了一层对数据进行加解密的SSL/TLS</p>
<ul>
<li>SSL: Secure Sockets Layer</li>
<li>TLS: Transport Layer Security</li>
</ul>
<p><br>HTTPS认证过程, 主要有三部分</p>
<ul>
<li>Server证书的认证阶段, 即得到CA机构的签名</li>
<li>Server跟Client之间通过非对称的方式验证彼此身份</li>
<li>Server跟Client之间通过双方认同的随机数做对称加密数据传输</li>
</ul>
<p><br><img src="https-1.svg" alt="证书的认证，以及HTTPS的工作流程.svg"></p>
]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>annotation定义的总结</title>
    <url>/2020/05/16/%5BAnnotation%5D%20annotation%E5%AE%9A%E4%B9%89%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Annotation-annotation定义的总结"><a href="#Annotation-annotation定义的总结" class="headerlink" title="[Annotation] annotation定义的总结"></a>[Annotation] annotation定义的总结</h1><p><a name="tyC3q"></a></p>
<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><ul>
<li><a href="https://juejin.im/post/5c63e2b0f265da2dd94c8e16" target="_blank" rel="noopener">https://juejin.im/post/5c63e2b0f265da2dd94c8e16</a> （@Inherited 使用注意点）</li>
</ul>
<br>
<br>


<table>
<thead>
<tr>
<th><strong>元注解</strong></th>
<th><strong>作用</strong></th>
<th><strong>使用注意点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Inherited</td>
<td>是否可以继承. 即子类是否可以不用定义直接使用父类的注解</td>
<td>使用@Inherited注意点<br>- @Inherited 并不会从接口中继承，而只会从class中继承<br>- 方法并不从它所重载的方法继承annotation<br></td>
</tr>
<tr>
<td>@Retention</td>
<td>表示在系统运行的哪个阶段出现</td>
<td>RetentionPolicy.RUNTIME - 会被compiler记住并且会在JVM 运行时存留<br>RetentionPolicy.<em>CLASS - 会被compiler记住但是不会在JVM中存留</em></td>
</tr>
<tr>
<td>@Documented</td>
<td>是否在javadoc中出现</td>
<td></td>
</tr>
<tr>
<td>@Target</td>
<td>定义的注解可以使用在那些地方</td>
<td>具体可以查看 ElementType的定义<br>ElementType.<em>METHOD - 可以使用在方法上</em><br>ElementType.<em>TYPE - 可以使用在class/interface上</em></td>
</tr>
</tbody></table>
<p><br>一个完整的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>( &#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TimeTraceLog &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Level <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> Level.WARN</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>getResourceAsStream 在class和classloader的异同</title>
    <url>/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p><a name="6kO5S"></a></p>
<h3 id="Java中加载资源，有两种方式"><a href="#Java中加载资源，有两种方式" class="headerlink" title="Java中加载资源，有两种方式"></a>Java中加载资源，有两种方式</h3><ul>
<li>通过classloader的getResourceAsStream</li>
<li>通过class的getResourceAsStream</li>
</ul>
<br>
<br>他们的相同点，都是去resources下找资源，不同点是class的getResourceAsStream在找资源之前会对参数"name"进行处理。以下为源码的简单分析<br>
<br>

<p><a name="C0wO2"></a></p>
<h4 id="java-lang-ClassLoader-getResourceAsStream"><a href="#java-lang-ClassLoader-getResourceAsStream" class="headerlink" title="java.lang.ClassLoader#getResourceAsStream"></a>java.lang.ClassLoader#getResourceAsStream</h4><ul>
<li>name传什么，就用该name去找，不会做而外的处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        URL url = getResource(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> url != <span class="keyword">null</span> ? url.openStream() : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><a name="tyQpQ"></a></p>
<h4 id="java-lang-Class-getResourceAsStream"><a href="#java-lang-Class-getResourceAsStream" class="headerlink" title="java.lang.Class#getResourceAsStream"></a>java.lang.Class#getResourceAsStream</h4><p>会先对传入的name做一层处理:</p>
<ul>
<li>如果name是以”/“为开头，那么不做处理，即: 从resources下找</li>
<li>如果name不是以”/“为开头，则会将 调用该方法的类的package加上去. 即会从resources下找”packageName”+”name”的资源. 比如”com.test.test-1.txt”</li>
</ul>
<p><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/1.png" alt="image.png"></p>
<ul>
<li>之后通过classloader去找资源<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        name = resolveName(name);</span><br><span class="line">        ClassLoader cl = getClassLoader0();</span><br><span class="line">        <span class="keyword">if</span> (cl==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A system class.</span></span><br><span class="line">            <span class="keyword">return</span> ClassLoader.getSystemResourceAsStream(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cl.getResourceAsStream(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a package name prefix if the name is not absolute Remove leading "/"</span></span><br><span class="line"><span class="comment">     * if name is absolute</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">resolveName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">while</span> (c.isArray()) &#123;</span><br><span class="line">                c = c.getComponentType();</span><br><span class="line">            &#125;</span><br><span class="line">            String baseName = c.getName();</span><br><span class="line">            <span class="keyword">int</span> index = baseName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">                name = baseName.substring(<span class="number">0</span>, index).replace(<span class="string">'.'</span>, <span class="string">'/'</span>)</span><br><span class="line">                    +<span class="string">"/"</span>+name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = name.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>
<br>

<p><a name="RvqPr"></a></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>在找不到资源的时候，可以查看下maven打出来的target中是否包含资源, 如果找得到，那就基本都能找到，否则就要看看pom.xml中是否在builder时候将对应的资源给exclude掉了(默认都是会将resources下的资源加载进来的)<br><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/2.png" alt="image.png"></p>
<p><a name="Oo89r"></a></p>
<h4 id="在main下的示例"><a href="#在main下的示例" class="headerlink" title="在main下的示例"></a>在main下的示例</h4><p>源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream fis1 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"hello.txt"</span>);</span><br><span class="line">        InputStream fis2 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"cloud_cert-daily.pfx"</span>);</span><br><span class="line">        InputStream fis3 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"cloud_root-daily.crt"</span>);</span><br><span class="line">        InputStream fis4 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"test.txt"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/3.png" alt="image.png"><br><a name="lLGB4"></a></p>
<h4 id="在test下进行的示例"><a href="#在test下进行的示例" class="headerlink" title="在test下进行的示例"></a>在test下进行的示例</h4><p>源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream fis1 = One.class.getClassLoader().getResourceAsStream("hello2.txt");</span><br><span class="line">        InputStream fis2 = One.class.getResourceAsStream("test-1.txt");</span><br><span class="line">        InputStream fis3 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"cert/pro/root-daily2.crt"</span>);</span><br><span class="line">        InputStream fis4 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"test2.txt"</span>);</span><br><span class="line">        InputStream fis5 = One.class.getResourceAsStream("/test3.txt");</span><br><span class="line">        InputStream fis6 = One.class.getResourceAsStream("/cert/pro/cert-daily1.pfx");</span><br><span class="line">        System.out.println(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/4.png" alt="image.png"><br><br><br></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis Interceptor使用</title>
    <url>/2020/05/23/Mybatis%20Interceptor%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="为什么Interceptor只能是固定的几种类型"><a href="#为什么Interceptor只能是固定的几种类型" class="headerlink" title="为什么Interceptor只能是固定的几种类型"></a>为什么Interceptor只能是固定的几种类型</h3><p><br>首先，interceptor中的类型，目前只有以下四种才能生效:</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<br>
<br>不能自定义，因为这样是找不到的，比如以下这种自定义的 LockPwdDAO.class 是找不到的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(</span><br><span class="line">        &#123;<span class="meta">@Signature</span>(type = LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"save"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"add"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"update"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"add"</span>, args = &#123;List<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"update"</span>, args = &#123;List<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"updateByIds"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TimeStampTransferInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>这是因为org.apache.ibatis.plugin.Plugin#wrap中会做校验，不是规范的类，是不会被处理的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">	<span class="comment">// 这里出来是空的</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">          <span class="comment">// 因为我们自定义的类，在这里是不会为true的. 因为c是: Executor,ParameterHandler, ResultSetHandler,StatementHandler 中的一个</span></span><br><span class="line">        <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><br>可以通过查看 org.apache.ibatis.plugin.Plugin#getSignatureMap 的调用链获取更详细的信息<br><img src="/2020/05/23/Mybatis%20Interceptor%E4%BD%BF%E7%94%A8/invoke-chain.png" alt="image.png"><br><br><br>org.apache.ibatis.plugin.InterceptorChain#pluginAll的入参是传入的，也就是 Executor/ ParameterHandler/ResultSetHandler/ StatementHandler 中的一个，知道这个之后@Intercepts的@Signature中的method也就知道怎么配置就一目了然了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>以下是 org.apache.ibatis.session.Configuration#newParameterHandler 的代码摘要:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<p><a name="hL9hH"></a></p>
<h3 id="最终可用代码示例"><a href="#最终可用代码示例" class="headerlink" title="最终可用代码示例"></a>最终可用代码示例</h3><p><br>以下的目的是: 对时间的统一处理，以免有的人用的时候传的13位(毫秒)，有的人使用的时候传的是10位，即秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Intercepts</span>( &#123;</span><br><span class="line">        <span class="meta">@Signature</span>(type = Executor<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"update"</span>, args = &#123;MappedStatement<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TimeStampTransferInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String targetStatementIdPrefix = <span class="string">"com.xxx.dao.yyy.impl.LockPwdDAO"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; targetMethod = Arrays.asList(<span class="string">"save"</span>, <span class="string">"add"</span>, <span class="string">"update"</span>, <span class="string">"batchUpdate"</span>, <span class="string">"updateByIds"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) args[<span class="number">0</span>];</span><br><span class="line">        Object param = args[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handleEffectiveInvalidTimeSet(mappedStatement, param);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"[time-stamp-interceptor] "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleEffectiveInvalidTimeSet</span><span class="params">(MappedStatement mappedStatement, Object param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// param</span></span><br><span class="line">        String mappedStatementId = mappedStatement.getId();</span><br><span class="line">        <span class="keyword">boolean</span> isTargetMethod = isTargetStatement(mappedStatementId);</span><br><span class="line">        <span class="keyword">if</span> (!isTargetMethod) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"[time-stamp-interceptor] fix effective/invalid time"</span> );</span><br><span class="line">        <span class="keyword">if</span> (param <span class="keyword">instanceof</span> LockPwdDO) &#123;</span><br><span class="line">            LockPwdDO lockPwd = (LockPwdDO) param;</span><br><span class="line">            updateEffectiveInvalidTime2Second(lockPwd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// see: org.apache.ibatis.session.defaults.DefaultSqlSession.wrapCollection</span></span><br><span class="line">        <span class="keyword">if</span> (param <span class="keyword">instanceof</span> DefaultSqlSession.StrictMap) &#123;</span><br><span class="line">            DefaultSqlSession.StrictMap strictMap= (DefaultSqlSession.StrictMap) param;</span><br><span class="line">            List&lt;LockPwdDO&gt; lockPwds = (List&lt;LockPwdDO&gt;) strictMap.get(<span class="string">"list"</span>);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(lockPwds)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (LockPwdDO lockPwd : lockPwds) &#123;</span><br><span class="line">                updateEffectiveInvalidTime2Second(lockPwd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTargetStatement</span><span class="params">(String mappedStatementId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isLockPwdStatement = StringUtils.startsWith(mappedStatementId, targetStatementIdPrefix);</span><br><span class="line">        <span class="keyword">if</span> (!isLockPwdStatement) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastDotIndex = targetStatementIdPrefix.length() + <span class="number">1</span>;</span><br><span class="line">        String method = mappedStatementId.substring(lastDotIndex);</span><br><span class="line">        <span class="keyword">return</span> targetMethod.contains(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateEffectiveInvalidTime2Second</span><span class="params">(LockPwdDO lockPwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lockPwd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long originalEffectiveTime = lockPwd.getEffectiveTime();</span><br><span class="line">        Long originalInvalidTime = lockPwd.getInvalidTime();</span><br><span class="line">        lockPwd.setEffectiveTime(format2FixedLength(originalEffectiveTime, <span class="number">10</span>));</span><br><span class="line">        lockPwd.setInvalidTime(format2FixedLength(originalInvalidTime, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">format2FixedLength</span><span class="params">(Long originalTime, <span class="keyword">int</span> targetLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (originalTime == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> originalTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> currLength = originalTime.toString().length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diffLen = targetLength - currLength;</span><br><span class="line">        <span class="keyword">if</span> (diffLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> originalTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> factor = Math.pow(<span class="number">10</span>, Math.abs(diffLen));</span><br><span class="line">        <span class="keyword">if</span> (diffLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Double tmp = originalTime / factor;</span><br><span class="line">            <span class="keyword">return</span> tmp.longValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diffLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Double tmp = originalTime * factor;</span><br><span class="line">            <span class="keyword">return</span> tmp.longValue();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> originalTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>定义好之后，需要将interceptor注入进 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.xxx.entity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath*:conf/mybatis/*.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"plugins"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lockPwdInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.xxx.interceptor.TimeStampTransferInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="多个interceptor的执行顺序"><a href="#多个interceptor的执行顺序" class="headerlink" title="多个interceptor的执行顺序"></a>多个interceptor的执行顺序</h3><p><br>定义在后面的会先执行。 以下定义中，<code>interceptor1</code> 会在 <code>interceptor2</code>之前执行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"plugins"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"com.tuya.hulk.dal.interceptor.Interceptor2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"com.tuya.hulk.dal.interceptor.Interceptor1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><br>执行的时候，是以以下顺序进行执行的<img src="/2020/05/23/Mybatis%20Interceptor%E4%BD%BF%E7%94%A8/interceptor-invoke-sequence.jpg" alt="interceptor-invoke-sequence.jpg"><br><br><br>所以在xml定义中的最后一个interceptor会被第一个执行，但是却最后一个执行完(因为要等其他interceptor执行完之后它才能结束)，所以可以在该Interceptor上做一些统一的处理(比如Exception的兜底处理，时间的统计等), 类似:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 统一的异常处理</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><br>那为什么执行顺序是这样的呢？<br>从 <code>org.apache.ibatis.plugin.InterceptorChain#pluginAll</code> 中可以找到答案:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 答案在这里</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>首先， 给 target 做plugin的时候，是按照 interceptors的顺序进行的，也就是按照interceptor在xml中的定义进行的</li>
<li>最上面的，先进行 <code>target = interceptor.plugin(target);</code> 后面的后进行</li>
<li>我们注意到  <code>interceptor.plugin(target);</code> 执行完之后是会将结果覆盖掉 target的，即每做一次 拦截器的plugin，target都是会变更的. 所以<ol>
<li>拦截器1 被插入到target</li>
<li>之后拦截器2再插进去</li>
<li>再之后是拦截器3</li>
<li>这样就形成像将羽毛球放入桶里一样，先进去的在最底下后进去的在最上面这样的队形:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拦截器3--&gt;拦截器2--&gt;拦截器1</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<ol start="4">
<li>所以在执行的时候，是在最上面的先进行执行, 即 拦截器3</li>
</ol>
]]></content>
      <categories>
        <category>mybatis</category>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的BeanFactory.getBeansOfType的坑</title>
    <url>/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p><a name="MojXv"></a></p>
<h3 id="背景及问题发现"><a href="#背景及问题发现" class="headerlink" title="背景及问题发现"></a>背景及问题发现</h3><p>有时候，我们会在spring的bean实例化之前做一些校验，比如校验某些package下的类的命名是否符合规范，此时就会去实现 BeanDefinitionRegistryPostProcessor 做一些事情<br><br><br>我们假设，我们需要校验的类都实现了一个interface，名叫: IProxyBaseService， 那么我们很自然的就会有以下思路</p>
<ul>
<li>获取所有 IProxyBaseService的bean的定义</li>
<li>通过该bean找到对应的class，然后通过反射校验他们的方法是否合规</li>
</ul>
<p><br>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, IProxyBaseService&gt; nameInstanceMap = beanFactory.getBeansOfType(IProxyBaseService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(nameInstanceMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nameInstanceMap.forEach((beanName, beanInstance) -&gt; &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfacesAsSet(beanInstance);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(interfaces)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; interfaceCls : interfaces) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ClassUtils.isAssignable(IProxyBaseService<span class="class">.<span class="keyword">class</span>, <span class="title">interfaceCls</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkInterfaceMethods(interfaceCls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><br>如果系统中使用了dubbo，那么坑就来了: 当果你的dubbo的配置是通过占位符来做的，那么你将获取不到对应占位符的值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"$&#123;zookeeper.address&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后报以下错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: zookeeper not connected</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient.&lt;init&gt;(CuratorZookeeperClient.java:83)</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter.createZookeeperClient(CuratorZookeeperTransporter.java:26)</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.support.AbstractZookeeperTransporter.connect(AbstractZookeeperTransporter.java:68)</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter$Adaptive.connect(ZookeeperTransporter$Adaptive.java)</span><br><span class="line">    at org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfiguration.&lt;init&gt;(ZookeeperDynamicConfiguration.java:62)</span><br><span class="line">    at org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory.createDynamicConfiguration(ZookeeperDynamicConfigurationFactory.java:37)</span><br></pre></td></tr></table></figure>

<p><br>这时候如果没有认真debug过，会认为zk链接不上了，然后把问题指向zk，从而偏离了问题的本质<br></p>
<p><a name="MERTr"></a></p>
<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><p>从报错看，我们可以讲断点放在 <code>CuratorZookeeperClient.java:83</code>， 然后会发现，此时的地址都是占位符的<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-1.png" alt="image.png"><br><br><br>此时我们可以将我们自己写的代码注释掉，看看结果是什么样的，会发现其实是有值的，那么可以断定是代码的问题<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-2.png" alt="image.png"><br><br><br><br><br><br><br>经过排查，发现这一行代码有问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, IProxyBaseService&gt; nameInstanceMap = beanFactory.getBeansOfType(IProxyBaseService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>该代码会去找IProxyBaseService类的bean，但是它是使用了缺省参数的方法:<br>org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeansOfType<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-3.png" alt="image.png"><br><br><br>再往下会发现<br>org.springframework.beans.factory.support.DefaultListableBeanFactory#doGetBeanNamesForType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的 allowEagerInit 会让条件为true</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">        (mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">                !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">    <span class="keyword">boolean</span> isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">    BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">    <span class="keyword">boolean</span> matchFound =</span><br><span class="line">            (allowEagerInit || !isFactoryBean ||</span><br><span class="line">                    (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">            (includeNonSingletons ||</span><br><span class="line">                    (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">        <span class="comment">// 会进入到这里去  </span></span><br><span class="line">        isTypeMatch(beanName, type);</span><br><span class="line">    <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">        <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line">        beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">        matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">        result.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>然后会进入到<br>org.springframework.beans.factory.support.AbstractBeanFactory#isTypeMatch的以下代码段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里会校验当前类是否是FactoryBean</span></span><br><span class="line"><span class="keyword">if</span> (FactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanType</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="comment">// If it's a FactoryBean, we want to look at what it creates, not the factory class.</span></span><br><span class="line">        beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-4.png" alt="image.png"><br>而org.apache.dubbo.config.spring.ReferenceBean 正好是一个FactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>这样就会尝试去实例化ReferenceBean了，最后就会走到org.apache.dubbo.config.spring.ReferenceBean#afterPropertiesSet， 由于现在还只是在BeanDefinition处理阶段，还并没有到占位符的设置阶段，所以是读取不到占位符的值的，所以它还是原来的模样: ${zookeeper.address}, 并没有变形<br>
<br>

<p><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-5.png" alt="image.png"></p>
<p><a name="up6HB"></a></p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>知道问题的原因了: beanFactory.getBeansOfType的参数allowEagerInit=true时会将FactoryBean初始化掉。<br>所以改起来也很简单，就是使用另外一个方法:<br><code>beanFactory.getBeansOfType(IProxyBaseService.class,false, false);</code><br><br><br>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, IProxyBaseService&gt; nameInstanceMap = beanFactory.getBeansOfType(IProxyBaseService<span class="class">.<span class="keyword">class</span>,<span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(nameInstanceMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nameInstanceMap.forEach((beanName, beanInstance) -&gt; &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfacesAsSet(beanInstance);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(interfaces)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; interfaceCls : interfaces) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ClassUtils.isAssignable(IProxyBaseService<span class="class">.<span class="keyword">class</span>, <span class="title">interfaceCls</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkInterfaceMethods(interfaceCls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><a name="LfS6k"></a></p>
<h3 id="事情还在继续"><a href="#事情还在继续" class="headerlink" title="事情还在继续"></a>事情还在继续</h3><p><br>然而事情并没有那么简单，在后面的测试中，会发现，实现了IProxyBaseService的类，其field都是null.<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-6.png" alt="image.png"><br><br><br>这很严重啊。既然是都为空，那么看看它是什么时候进行初始化的，然后找了一个类，在其后面加了个InitializingBean进行断点调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceProxyServiceImpl</span> <span class="keyword">implements</span> <span class="title">IDeviceProxyService</span>, <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>debug后，发现这是从 beanFactory.getBeansOfType(IProxyBaseService.class,false, false); 调用过来的。<br>代码如下: org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeansOfType<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.这一行，是FactoryBean初始化的问题的根源</span></span><br><span class="line">        String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, T&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, T&gt;(beanNames.length);</span><br><span class="line">        <span class="comment">// 2.可是事情并没有完，当找出了IProxyBaseService这个类的beanName之后，就到了这</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 这里有一个getBean，然后就会去创建bean. 而此时bean都还没有实例化出来，所以都是null </span></span><br><span class="line">                result.put(beanName, getBean(beanName, type));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><br>解决方法是, 不使用beanFactory.getBeansOfType， 而是使用BeanDefinitionRegistry去获取对应的beanName，然后找到对应的class做自己的业务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       String[] beanNames = registry.getBeanDefinitionNames();</span><br><span class="line">       <span class="keyword">if</span> (beanNames == <span class="keyword">null</span> || beanNames.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">           BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);</span><br><span class="line">           String beanClsName = beanDefinition.getBeanClassName();</span><br><span class="line">           <span class="keyword">if</span> (!StringUtils.contains(beanClsName, <span class="string">"com.xxx.impl"</span>)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Class cls = ClassUtils.resolveClassName(beanClsName, Thread.currentThread().getContextClassLoader());</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfacesAsSet(cls);</span><br><span class="line">           <span class="keyword">if</span> (CollectionUtils.isEmpty(interfaces)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; interfaceCls : interfaces) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ClassUtils.isAssignable(IProxyBaseService<span class="class">.<span class="keyword">class</span>, <span class="title">interfaceCls</span>)) </span>&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               checkInterfaceMethods(interfaceCls);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><a name="dyGDj"></a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在bean没有实例化好的时候，不能随便使用beanFactory.getBeansOfType这个方法，这个会坑死人的</li>
<li>在bean没有实例化时做一些校验，能减少系统资源的开销(链接创建/资源分配等)，但实现的时候需要千万小心</li>
</ul>
<br>

]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《领域驱动设计精粹》-读书笔记</title>
    <url>/2020/05/30/%E3%80%8A%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B2%BE%E7%B2%B9%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a name="xJ6L8"></a></p>
<h3 id="chapter-1-设计"><a href="#chapter-1-设计" class="headerlink" title="chapter 1: 设计"></a>chapter 1: 设计</h3><ul>
<li>过度设计，毫无设计，都是不可取的；最好的是适度设计，演进式地对设计进行升级改造而不是一蹴而就的</li>
<li>闭门造车想出来的产品功能，也是不可取的</li>
<li>不是有效设计就是糟糕的设计，不存在什么“毫无设计”一说</li>
<li>领域设计中有两个概念<ul>
<li>战略设计，是高层次的设计，一般是划分上下文</li>
<li>战术设计，是上下文中实现的设计</li>
</ul>
</li>
</ul>
<br>
<br>

<p><a name="7o3tN"></a></p>
<h3 id="chapter-2-限界上下文的定义"><a href="#chapter-2-限界上下文的定义" class="headerlink" title="chapter 2: 限界上下文的定义"></a>chapter 2: 限界上下文的定义</h3><ol>
<li>MVP(Minimum Viable Product)产品原则: 功能最小的产品原则，提倡在产品需求研发过程中聚焦于最小化可行产品上，不断获取用户的反馈并持续迭代。韩国的一些电视剧的拍摄模式就采用类似这样的方式，先拍几集播放出来之后看市场反馈，如果ok则开始写接下来的剧本并拍摄，否则可能就面临砍掉的风险</li>
</ol>
<ol start="2">
<li>同时在需求评审过程中，不要过早地提及技术实现细节，毕竟技术是为产品服务的，如果产品功能合理，那么就需要花时间去攻克技术难点。若时间不允许，在评审中可以考虑让产品功能以另外一种方式实现。所以要先了解需求之后再进行技术的评估，不要让技术引导产品的走向(虽然有时候这种方式能带来很好的效果)</li>
</ol>
<ol start="3">
<li>限界上下文，这个其实就是领域的概念了. 不同的限界上下文中<ul>
<li>他们的仓库一般都是不一样的。即代码各管个的</li>
<li>他们的规范也可能是不一样的，每个限界上下文的规范可能是自成一派.</li>
<li>开发的时候，一般是一个团队负责一个限界上下文，如果其他团队希望来共建，那么也是可以的，但前提是需要遵守该限界上下文中的规范，提交的代码由该限界上下文的负责团队进行review审批</li>
</ul>
</li>
</ol>
<ol start="4">
<li>限界上下文的定义过程中<ul>
<li>要遵循只有最核心的概念才能归属于该限界上下文，不是核心的不要进来. 否则该限界上下文将会变得非常庞大，最终成为一个大泥球</li>
<li>一个概念要加进来的时候，要去质疑它是否是核心概念？够不够资格？</li>
<li>限界上下文的定义是一个渐进过程，研发人员/测试人员/业务专家(通常是产品)等角色都可能会发现问题，当发现问题的时候最好大家一起当面沟通，提高效率. 毕竟沟通过程中可能会有其他问题迸出来</li>
<li>领域模型的定义，不要跟相关的实现技术糅合在一起，因为领域模型是跟技术无关的，用哪种技术实现都是ok的</li>
</ul>
</li>
</ol>
<br>

<ol start="5">
<li>在没有很好划分限界上下文的时候，系统可能就是一个大泥球(Ball of Mud), 之所以这么说是因为系统是有多个没有明确边界并且纠缠在一期的模型组成，类似麻花拧在一块，内部的连线错综复杂。没人敢乱动，也没人想去动</li>
</ol>
<br>

<ol start="6">
<li>在进行领域划分的时候，可能会遇到一个术语在不同的领域内表达的含义不一样，这时候就要考虑在每一个领域内都定义一个该术语以清晰的表达业务含义。但需要注意的是，在各自的领域内命名需要遵循正交性，比如在很多地方都有一个叫西湖的，比如<ul>
<li>杭州西湖</li>
<li>惠州西湖</li>
</ul>
</li>
</ol>
<p>但是在在自己领域内(比如在杭州)就没必要说将该湖命名为杭州西湖，直接将其命名为西湖即可。因为它和它所在的领域正交起来就是: 杭州西湖<br><br><br></p>
<ol start="7">
<li>只有业务复杂复杂到一定程度的时候才需要考虑使用DDD模式进行开发，如果业务很简单，只有CRUD并且不涉及到其他系统，那么就没有必要使用DDD。否则会增加系统的复杂性</li>
</ol>
<br>

<ol start="8">
<li>在软件的整个生命周期中，都需要创新. 但是我们会有这么一个误区: 需求迭代过程中我们会进行创新，毕竟迭代的时候会有新的功能点出来，但是等到软件进入维护阶段则不会进行创新了，但这是错误的，因为维护阶段不代表软件已经死了，只是该阶段的创新相比其他阶段会少一些，但不能说停止了</li>
</ol>
<br>

<ol start="9">
<li>DDD的限界上下文的划分跟微服务的粒度的大小的定义很相似。 其实DDD中的一个限界上下文内可能包含多个微服务。微服务粒度的划分，没有一个标准答案，因为它是一个设计决策，微服务的粒度其实是团队做出的决策，在决定之前团队对它的粒度可以进行质疑探讨，毕竟这是一个架构设计。可以从以下几点去考虑自己的微服务粒度大小<ul>
<li>现有架构间的依赖关系</li>
<li>业务的扩展性</li>
<li>团队人员的能力</li>
<li>最后是在实现期间可能会遇到的风险和挑战</li>
</ul>
</li>
</ol>
<br>
<br>

<p><a name="7Vt1w"></a></p>
<h3 id="chapter-3-子域"><a href="#chapter-3-子域" class="headerlink" title="chapter 3: 子域"></a>chapter 3: 子域</h3><p><br>子域是一个小的功能领域，在java中就是一个package的划分。 在使用DDD时，理想情况下是一个限界上下文对应一个子域(1:1的关系)，因为这样可以让限界上下文的目标清晰并且专注于核心战略。如果必须在同一个界限上下文(核心域)中创建第二个模型，那么应该使用一个完全独立的模块将该模型从核心域中分离出来(在java中就是新建一个package)。<br><br><br>子域分为3中类型</p>
<ul>
<li>核心域，这种类型的域是唯一的并且定义明确的领域模型，是团队甚至公司的区分其他竞争对手的核心所在，需要花大力气大资源去攻克的领域，是公司/团队的战略所在</li>
<li>支撑子域，这类领域通常是定制的，一般可复用性较差，可以花较少的精力去做</li>
<li>通用子域，这一类的领域通常是各个领域公共的，构建的时候主要需要考虑其稳定性和兼容性，不要影响到其他的域，毕竟是公用的</li>
</ul>
<p><br>他们之间的重要性: 核心域 &gt; 支撑子域 &gt; 通用子域。对于一个大泥球系统，可以尝试对其进行子域划分，这样可以把问题划分清除，方便后期进行改造迁移<br><br><br></p>
<p><a name="UzyMc"></a></p>
<h3 id="chapter-4-界限上下文之间的关系与交流"><a href="#chapter-4-界限上下文之间的关系与交流" class="headerlink" title="chapter 4: 界限上下文之间的关系与交流"></a>chapter 4: 界限上下文之间的关系与交流</h3><p><br>界限上下文之间的关系，其实跟微服务之间的关系大同小异，它们之间的关系有:</p>
<ul>
<li>合作关系。这种关系各个团队有共同的目标，大家步调一致。但是要注意的是合作要有一个期限，不能永久合作，因为只有设置了期限才能保持一个良性的合作，否则很可能到后面两个领域模型不区分彼此糅合在一起形成”大泥球”</li>
<li>共享内核。该关系意味着各个领域模型之间有交集，大家需要共建该交集。可以采用内部开源的方式进行共建(大家遵循一定的规范进行代码维护集成)</li>
<li>客户-供应商关系。该关系就是有一方需要依赖另一方提供的服务才能进一步业务展开，这时候<ul>
<li>作为服务提供方的服务需要注意在升级API的时候要做兼容</li>
<li>使用方(客户方)，则需要遵循提供方的游戏规则进行玩耍，会有点被动；但好处是可以借助大树好乘凉，比如借助阿里云平台/amazon平台，快速搭建服务开展业务，缺点是很多产品只能使用所选云平台的服务</li>
</ul>
</li>
<li>防腐层。每个界限上下文使用该层来隔离依赖领域的升级对自己领域的侵入，防腐层一般都会将依赖领域的业务术语翻译成自己领域内的业务语言，相同的也会将自己的业务语言转化为依赖领域的业务语言，充当一个翻译官的角色。这一层做好之后，可以在这一层上面做一层熔断降级，减少被依赖服务弄死的情况</li>
<li>API模式<ul>
<li>改种模式跟 客户-供应商 关系类似</li>
<li>服务与服务之间通过 API进行交流</li>
<li>API的提供方需要提供完备的 API文档以让使用方快速入手，很适合没有时间构建自己的防腐层的领域</li>
</ul>
</li>
<li>各行其道。这种模式是DDD最希望看到的，就是各个领域各管各的，互不相干</li>
</ul>
<br>

<p><a name="noN1M"></a></p>
<h4 id="领域之间的交流方式"><a href="#领域之间的交流方式" class="headerlink" title="领域之间的交流方式"></a>领域之间的交流方式</h4><p>跟微服务之间的沟通交流方式是一样的，分以下几种</p>
<ul>
<li>RPC，自己在TCP之上做了一层，用于各个服务的通信. 序列化基本都会自己做，适合数据块小的场景</li>
<li>RESTful<ul>
<li>REST就是把服务当作资源来使用了</li>
<li>一般是HTTP协议进行，可以适配数据量大的场景，但是会由于HTTP封包/拆包，header过多等问题导致资源利用率不高的问题</li>
<li>需要注意的是REST API的定义需要根据 调用方的需求来，而不是提供方想怎么就怎么样。因为提供方自己臆想出来的API可能根本满足不了调用方的需求</li>
</ul>
</li>
<li>消息通知<ul>
<li>一般都是至少触达一次</li>
<li>需要考虑<ul>
<li>重复消费时，保证业务的幂等</li>
<li>对于消息延迟达到，需要在系统设计之处就考虑进去，做好相应的处理，保证系统的健壮性</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<br>以上几种方式，都需要注意一点，就是避免连坐效应的发生:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A ---&gt; B ---&gt; C</span><br></pre></td></tr></table></figure>
由于B调用C慢导致A调用B被连坐，这里可以通过超时机制/异步机制等方式进行解决<br>
<br>
<br>在DDD模型中，通过 消息通知 进行上下文界限的沟通交流，一般是

<ul>
<li>通过领域模型中的 aggregate发布的Domain Event</li>
<li>感兴趣的领域会收到 Domain Event，进行自己的业务处理</li>
<li>由于可能会有多个consumer，所以发出的 Domain Event中的数据可以有两种<ul>
<li>肥胖型的Domain Event: 里面包含的数据内容涵盖大部分的consumer所需的数据<ul>
<li>这样会造成Domain Event中的数据很多</li>
<li>数据多容易造成数据安全问题</li>
<li>同时对传输带宽会形成压力</li>
<li>对每个consumer来说也会有压力，因为可能当前consumer只想要Domain Event中的几个字段，其他的字段都是无用的。解析起来很费劲</li>
</ul>
</li>
<li>瘦弱型的: 只提供极精简的数据，各个consumer如果需要其他而外的数据，可以通过 事件源领域的API进行查看<ul>
<li>当然这样也会造成多次的领域间的通信，因为当consumer需要额外的数据时，就必须通过调用API的方式获取数据</li>
<li>但对于大部分consumer来说，Domain Event中的基本数据是能满足它们的业务需求的</li>
</ul>
</li>
<li>具体选择 瘦子还是胖子，要根据自己的业务来定</li>
</ul>
</li>
</ul>
<br>
<br>

<p><a name="t7UGf"></a></p>
<h3 id="chapter-5-聚合"><a href="#chapter-5-聚合" class="headerlink" title="chapter 5: 聚合"></a>chapter 5: 聚合</h3><p>聚合简单的理解，就是根据业务将一些相关的逻辑聚在一起，并且它们之间的状态会保持一致，所以一般来说一个聚合就是一个事务。聚合有几个重要的元素</p>
<ul>
<li>实体，可以认为是一个数据的表示，但跟面向对象中的实体稍微会不一样，因为DDD中的实体其实是充血对象，里面除了属性之外，还会有行为</li>
<li>值对象，对，它们就是值，在生成之后就不变的东西，比如常量，或者是一个实体的id(生成之后是不会变的)</li>
</ul>
<p><br>每个聚合有一个根实体，该实体控制着聚合内的其他元素，一般聚合的名称就是按照根实体的名称来命名<br><br><br><br><br>聚合经验法则</p>
<ul>
<li>在聚合边界内保护业务规则保持不变，即保持事务一致<ul>
<li>考虑的时候，将状态有关联性的东西放在一起，形成一个聚合</li>
<li>提交的时候一起提交，保证各自的状态保持正确，不会错乱</li>
<li>一般有个原则就是，需要即时响应发生的，放在一个聚合里。可以延时发生的，可以放到不同的聚合，通过领域事件保持最终一致性</li>
</ul>
</li>
<li>聚合不要设计的太大，要尽量小，否则会变得很臃肿<ul>
<li>不要将两个实体放在一个聚合内，否则会将聚合撑大</li>
</ul>
</li>
<li>不同聚合之间通信通过标识来引用</li>
<li>不同聚合之间，通过最终一致性来保持</li>
</ul>
<br>
<br>关于贫血模型: 对象中，只有Getter/Setter，没有其他的业务行为。一般的贫血模型，都是在外面进行业务设置，或者在工具类中进行业务处理. 这样的好处是: 保持对象的干净；坏处就是业务会散落在各处，会不好管理<br>
<br>充血模型，在DDD中会将业务都封装在对象中，这样业务管理比较方便。但对熟悉面向对象的朋友可能会不太好理解<br>
<br>

<p><a name="kkz3r"></a></p>
<h3 id="chapter-6-领域事件"><a href="#chapter-6-领域事件" class="headerlink" title="chapter 6: 领域事件"></a>chapter 6: 领域事件</h3><p><br>领域事件，是不同聚合沟通的桥梁。一般领域事件的触发有两种情况</p>
<ul>
<li>由命令触发，所谓命令是由用户操作了某个动作而发出的指令。由命令触发而来的领域事件，在处理的时候可以根据业务需要拒绝处理</li>
<li>由于时间到了而触发，即时间领域事件。该类领域事件不能拒绝，必须无条件地进行处理</li>
</ul>
<br>
<br>领域事件的其他

<ul>
<li>一般领域事件的内容中都有一个sourceId，由于记录该事件的发起方是谁. 比如我们发送MQ消息的时候，也会这么干，这样有助于在处理的时候进行适当的分派；</li>
<li>领域事件的命名，一般通过命令来。并且是过去式. 比如命令叫: bookHotel, 那么事件的名称就是: hotelBooked</li>
<li>所谓事件溯源，就是将发生的事情都记录起来，方便后面排查只用。平时使用的记录表就能起到这种作用，这个也是要根据实际情况操作的，并不是所有的聚合都需要事件溯源的</li>
</ul>
<br>

<p><a name="3cd7Q"></a></p>
<h3 id="chapter-7-工具"><a href="#chapter-7-工具" class="headerlink" title="chapter 7: 工具"></a>chapter 7: 工具</h3><p>事件风暴，就是快速的聚焦地分析问题-&gt;发现问题-&gt; 找到方案-&gt; 进而形成共识，主要步骤包括</p>
<ul>
<li>将大家聚在一起(开发+测试+需求方)，快速对需求过一遍，然后找到核心的领域事件</li>
<li>针对找到的领域事件，定义触发这些领域事件的命令</li>
<li>将领域事件+命令，通过实体/聚合关联起来</li>
<li>然后将聚合的流转方向定义清楚，形成一个业务流</li>
<li>最后如果有需要，可以在业务流的基础上，创建一些视图，从而可以提供更宏观层面的东西.这一步个人理解是对业务的抽象，从而更能抓住业务核心，并且可以用它来评估是否符合公司战略</li>
</ul>
<br>
<br>

<p><a name="nlhgQ"></a></p>
<h4 id="敏捷开发相关"><a href="#敏捷开发相关" class="headerlink" title="敏捷开发相关"></a>敏捷开发相关</h4><ul>
<li>No Estimates(拒绝估算): 不是否定敏捷开发的开始阶段的估算所产生的价值，而是探索在持续改进的过程中是否有一些手段可以协助或者改善估算活动，从而更加聚焦于交付价值。实践者一般会在估算阶段减少可以用的估算值的数量，比如只提供 0.5/1/3的牌，这样每个估算的得分都会很低，然后再推动团队将每个 user story进行拆解，如果可以拆解的够细，那么当task足够小交付足够快时，就可以不用对其做估算了。这样做的目的是希望更加聚焦于价值交付，而非将时间精力浪费在估算环节</li>
<li>敏捷的核心是知识获取(Knowledge Acquisition)。 通过站会，通过快速迭代，通过回顾会议等形式，快速获取到团队遇到的问题，客户的反馈等知识，从而做调整进行下一个优化迭代</li>
</ul>
<br>

<p><a name="fp5Pf"></a></p>
<h4 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h4><p>一种项目管理的方式，主要的思路是: 找到问题 –&gt; 然后找到应对之策。一般会通过划分四个象限来明确各个领域的现状</p>
<ul>
<li>S: Strength，优势是什么</li>
<li>W: Weakness，当前团队的弱点是什么. 这个不能隐藏的，否则将不自量力</li>
<li>O: Opportunity， 当前的机遇是什么，这是要将力量集中起来去抓住它攻破的东西</li>
<li>T: Threat, 威胁是什么，或者说障碍是什么</li>
</ul>
<p><br>通过分析S+W，可以对团队有一个清晰的认识。通过O+T可以知道面对的是什么，对处境及整体环境有一个较好的认知</p>
]]></content>
      <categories>
        <category>设计</category>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>maven知识整理+插件编写</title>
    <url>/2020/06/13/maven%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86+%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p><a name="9xWL1"></a></p>
<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><ul>
<li><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a> (仲裁机制+scope等知识)</li>
<li><a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a> (lifeCycle+phase+goal)</li>
<li><a href="https://maven.apache.org/guides/plugin/guide-java-plugin-development.html" target="_blank" rel="noopener">https://maven.apache.org/guides/plugin/guide-java-plugin-development.html</a> （插件编写）</li>
<li><a href="https://maven.apache.org/guides/mini/guide-configuring-plugins.html#Using_the_executions_Tag" target="_blank" rel="noopener">https://maven.apache.org/guides/mini/guide-configuring-plugins.html#Using_the_executions_Tag</a> (插件参数的配置)</li>
</ul>
<br>
<br>我们都知道，maven可以帮助我们管理依赖，否则我们就需要采用古老的方式，单独从其他地方找到对应的jar，然后放到classpath中，这样很麻烦也很容易出现兼容问题.<br>

<p><a name="AkmXp"></a></p>
<h3 id="maven的一些知识整理"><a href="#maven的一些知识整理" class="headerlink" title="maven的一些知识整理"></a>maven的一些知识整理</h3><p><a name="l0Npl"></a></p>
<h4 id="1-maven的仲裁机制"><a href="#1-maven的仲裁机制" class="headerlink" title="1. maven的仲裁机制"></a>1. maven的仲裁机制</h4><p>所谓仲裁，就是出现冲突时会怎么抉择。maven会将项目的依赖信息，做成一棵树的形状，如果有两个一样的jar，但他们的版本不一样</p>
<ul>
<li>离树根越近的那个会被选中;</li>
<li>如果他们两个离树根的距离相等，那么就看谁是第一个被发现(依靠他们在pom中的顺序)</li>
</ul>
<p>比如A项目中有两个D的jar(他们分别是被不同的jar带进来的)，但是版本不一样, 路径如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A-&gt;B-&gt;D1.0</span><br><span class="line">A-&gt;C-&gt;E-&gt;D2.0</span><br></pre></td></tr></table></figure>
<p>那么D1.0会被选中</p>
<p><a name="zs5en"></a></p>
<h4 id="2-exclude-optional的区别"><a href="#2-exclude-optional的区别" class="headerlink" title="2.  exclude+optional的区别"></a>2.  exclude+optional的区别</h4><p>在依赖某个dependency的时候，我们可能不想要某个dependency，那么我们可以显式的通过exclude将其剔除掉，比如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>其实还有一种方式，就是optional方式，optional的意思相当于”exclude by default”, 即默认被排除掉. 比如我们在开发项目的时候，会觉得我们依赖的某个jar并不是 依赖我们所必须的，这时候就可以将其标记位optional。假设</p>
<ul>
<li>A项目依赖了<code>org.yaml:snakeyaml:1.20</code>但又不希望将它传递给依赖自己的B，那么可以在pom中作以下的dependency声明</li>
<li>那么B引用A的时候， <code>org.yaml:snakeyaml:1.20</code> 是不会加到B中来的。如果需要加进来，B自己可以显式地在自己的pom中进行定义<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<br>
<a name="HYXQc"></a>

</li>
</ul>
<h4 id="3-一个dependency的表示"><a href="#3-一个dependency的表示" class="headerlink" title="3. 一个dependency的表示"></a>3. 一个dependency的表示</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>stage<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般的我们引入一个dependency的时候，我们只要定义其GAV(groupId, artifactId, version)即可。其实一个dependency完整的表示应该包含: GAV+type+classifier</p>
<ul>
<li>type: 表示当前是什么类型. 因为默认type=jar，所以很多时候我们不定义. 但是如果对应的dependency不是jar则需要显式声明</li>
<li>classifier: 表示当前是那种用途的，该值默认为null。比如同一个依赖(即GAV+type一样)，但是需要适应于不同的业务场景，比如一个是给客户A用的，一个是给客户B用的，那么就可以使用classifier来区分了。比如json-lib可能需要同时提供给jdk13和jdk15</li>
</ul>
<p><img src="/2020/06/13/maven%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86+%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/m-1.png" alt="image.png"><br></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.json-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk15<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><a name="zuglD"></a></p>
<h4 id="4-dependency的scope及其传递性"><a href="#4-dependency的scope及其传递性" class="headerlink" title="4. dependency的scope及其传递性"></a>4. dependency的scope及其传递性</h4><p>dependency的scope表示其作用范围，同时也确定了其传递性，有6个scope<br></p>
<table>
<thead>
<tr>
<th>scope</th>
<th>特性</th>
<th>是否会传递给依赖项</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>默认的scope</td>
<td>是</td>
</tr>
<tr>
<td>provided</td>
<td>跟compile类似. 不同之处在于:它期望在运行时JDK或者Container会提供该dependency. <br></td>
<td>否</td>
</tr>
<tr>
<td>runtime</td>
<td>在compile阶段不是必须的，是给运行时准备的</td>
<td>否</td>
</tr>
<tr>
<td>test</td>
<td>测试时使用的</td>
<td>否</td>
</tr>
<tr>
<td>system</td>
<td>跟provided类似，但是它不会区从仓库中查找对应的dependency，而是通过指定的路径区找</td>
<td>否</td>
</tr>
<tr>
<td>import</td>
<td>将另一个pom引入进来</td>
<td>是</td>
</tr>
</tbody></table>
<br>
<a name="tvvmD"></a>

<h3 id="插件相关"><a href="#插件相关" class="headerlink" title="插件相关"></a>插件相关</h3><p><a name="ZjN36"></a></p>
<h4 id="1-生命周期简单介绍"><a href="#1-生命周期简单介绍" class="headerlink" title="1. 生命周期简单介绍"></a>1. 生命周期简单介绍</h4><p><br>maven是基于build lifecycle的概念设计出来的，有三个生命周期:</p>
<ul>
<li>clean, 清理上次build的数据</li>
<li>default，负责编译打包部署</li>
<li>site，负责文档的生成</li>
</ul>
<p>其中default+clean是我们平时接触比较多的。而每个生命周期都是由多个phase组合而成的，一个phase对应一个plugin，它可能会包含多个goal. 其中goal就是一个具体的执行任务了，大致结构如下<br><img src="/2020/06/13/maven%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86+%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/lifecycle-structure.jpg" alt="生命周期.jpg"><br><br><br>其中一个phase由0个或者多个goal组成，如果该phase中没有一个goal，那么它不会执行；但如果它有多个goal，那么没有特别指定执行那个goal的情况下，它下面的所有goal都会执行。有一点需要注意的是，执行一个phase时，在它之前的所有phase都会被先执行。phase可以直接被执行，就像我们平时的 mvn clean install 其实都是直接执行phase的，只是里面的goal会被全部执行而已</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean myPhase:myGoal package</span><br></pre></td></tr></table></figure>
<p>考虑以上命令，其中clean和package是一个phase，而myPhase:myGoal是一个goal。那么这条命令会如下执行</p>
<ul>
<li>执行clean phase之前的所有phase</li>
<li>执行clean phase</li>
<li>执行 myPhase:myGoal</li>
<li>执行package之前的所有phase</li>
<li>执行package phase</li>
</ul>
<br>
<br>default build lifecycle 会包含以下phase

<ul>
<li>validate - 检查项目的正确性，比如是否有东西缺失</li>
<li>compile - 编译项目的源代码</li>
<li>test - 对编译好的代码进行测试. 可以通过 <code>-Dmaven.test.skip=true</code> 参数跳过该阶段</li>
<li>package - 对编译好的代码进行打包，通过该phase可以生成jar，所以平时我们会执行<code>mvn clean package</code> 进行打包动作</li>
<li>verify - 对测试结果进行验证，以确保达到了预期的标准</li>
<li>install -将打好的包安装到本地仓库，以方便本地的其他项目可以使用</li>
<li>deploy - 将打好的包上传到远程仓库，方便其他项目可以下载使用.</li>
</ul>
<br>

<p><a name="mIuQO"></a></p>
<h4 id="2-插件编写"><a href="#2-插件编写" class="headerlink" title="2. 插件编写"></a>2. 插件编写</h4><p>其实插件的编写就是一个写Mojo的过程. 在写好之后，如果要单独执行对应的goal需要执行如下命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn &#123;groupId&#125;:&#123;artifactId&#125;:&#123;version&#125;:&#123;goalName&#125;</span><br></pre></td></tr></table></figure>
<p>这个命令太长了，我们可以通过配置做做一些精简</p>
<ol>
<li><p>在pom中通过引入maven-plugin-plugin插件增加goalPrefix</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goalPrefix</span>&gt;</span>duplicate<span class="tag">&lt;/<span class="name">goalPrefix</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时在maven的settings.xm文件中配置如下信息. settings.xml文件的位置:</p>
<ol>
<li>自己的: <code>${user.home}/.m2/settings.xml</code></li>
<li>全局的(大家都可以看到的): <code>${maven.home}/conf/settings.xml</code></li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><a name="xjKBE"></a></p>
<h5 id="一个插件的具体的例子"><a href="#一个插件的具体的例子" class="headerlink" title="一个插件的具体的例子"></a>一个插件的具体的例子</h5><ol>
<li>pom.xml文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>duplicate-check<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>maven-plugin<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">java.encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugin-tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>backport-util-concurrent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>backport-util-concurrent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.shared<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-tree<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;java.encoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goalPrefix</span>&gt;</span>duplicate<span class="tag">&lt;/<span class="name">goalPrefix</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>initialize<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>properties<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>DuplicateClassCheckMojo.java 文件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.artifact.Artifact;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.execution.MavenSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugin.AbstractMojo;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugin.MojoExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugin.MojoFailureException;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.Component;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.LifecyclePhase;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.Mojo;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.Parameter;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.ResolutionScope;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.project.DefaultProjectBuildingRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.project.MavenProject;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.project.ProjectBuildingRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.shared.dependency.graph.DependencyNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requiresDependencyResolution的含义: 依赖包之间的关系是否需要已经存在? 如果有的依赖包不存在或者下载不下来 需不需要报错？ 这个默认是runtime, 即只会检验scope=compile+runtime的依赖</span></span><br><span class="line"><span class="meta">@Mojo</span>(name = <span class="string">"class-check"</span>, defaultPhase = LifecyclePhase.VALIDATE, requiresDependencyResolution = ResolutionScope.TEST, requiresDependencyCollection = ResolutionScope.TEST)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuplicateClassCheckMojo</span> <span class="keyword">extends</span> <span class="title">AbstractMojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameter</span>(defaultValue = <span class="string">"$&#123;project&#125;"</span>, readonly = <span class="keyword">true</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> MavenProject project;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameter</span>(defaultValue = <span class="string">"$&#123;session&#125;"</span>, readonly = <span class="keyword">true</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> MavenSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span>(hint = <span class="string">"default"</span>)</span><br><span class="line">    <span class="keyword">private</span> DependencyGraphBuilder dependencyGraphBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当有duplicate的时候，是否需要失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span>(defaultValue = <span class="string">"true"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> failOnDuplicate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要检查的groupIds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span></span><br><span class="line">    <span class="keyword">private</span> String[] excludeGroupIds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要检查的 artifactIds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span></span><br><span class="line">    <span class="keyword">private</span> String[] excludeArtifactIds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要检查的 类名字(是类的全名, 比如: com.demo.DuplicateClassFoundMojo)的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span></span><br><span class="line">    <span class="keyword">private</span> String[] excludeClassPrefixes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DependencyNode dependencyNode = getDependencyNode();</span><br><span class="line">        <span class="keyword">if</span> (dependencyNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            getLog().info(DuplicateClassConstants.LOG_TAG + <span class="string">"dependencyNode is null"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Artifact&gt; totalArtifactIds = getArtifacts(dependencyNode);</span><br><span class="line">        resolveDependencies(totalArtifactIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DependencyNode <span class="title">getDependencyNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProjectBuildingRequest buildingRequest = <span class="keyword">new</span> DefaultProjectBuildingRequest(session.getProjectBuildingRequest());</span><br><span class="line">        buildingRequest.setProject(project);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dependencyGraphBuilder.buildDependencyGraph(buildingRequest, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DependencyGraphBuilderException e) &#123;</span><br><span class="line">            getLog().info(DuplicateClassConstants.LOG_TAG + <span class="string">"get dependency tree info failed: "</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;Artifact&gt; <span class="title">getArtifacts</span><span class="params">(DependencyNode dependencyNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Artifact artifact = dependencyNode.getArtifact();</span><br><span class="line">        <span class="keyword">if</span> (!isAllowedArtifact(artifact)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;DependencyNode&gt; children = dependencyNode.getChildren();</span><br><span class="line">        Set&lt;Artifact&gt; totalArtifacts = Sets.newHashSetWithExpectedSize(children != <span class="keyword">null</span> ? children.size() + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        totalArtifacts.add(artifact);</span><br><span class="line">        <span class="keyword">if</span> (children != <span class="keyword">null</span> &amp;&amp; !children.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DependencyNode child : children) &#123;</span><br><span class="line">                Artifact childArtifact = child.getArtifact();</span><br><span class="line">                <span class="keyword">if</span> (!isAllowedArtifact(childArtifact)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                totalArtifacts.add(childArtifact);</span><br><span class="line">                List&lt;DependencyNode&gt; myChildren = child.getChildren();</span><br><span class="line">                <span class="keyword">if</span> (isCollectionEmpty(myChildren)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (DependencyNode myChild : myChildren) &#123;</span><br><span class="line">                    Set&lt;Artifact&gt; artifactFromChild = getArtifacts(myChild);</span><br><span class="line">                    <span class="keyword">if</span> (!isCollectionEmpty(artifactFromChild)) &#123;</span><br><span class="line">                        totalArtifacts.addAll(artifactFromChild);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalArtifacts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAllowedArtifact</span><span class="params">(Artifact artifact)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> artifact != <span class="keyword">null</span> &amp;&amp; !Artifact.SCOPE_TEST.equals(artifact.getScope());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCollectionEmpty</span><span class="params">(Collection myChildren)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myChildren == <span class="keyword">null</span> || myChildren.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resolveDependencies</span><span class="params">(Set&lt;Artifact&gt; totalArtifactIds)</span> <span class="keyword">throws</span> MojoFailureException, MojoExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (totalArtifactIds == <span class="keyword">null</span> || totalArtifactIds.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; skipCheckGroupIds = excludeGroupIds == <span class="keyword">null</span> ? Collections.emptySet() : Sets.newHashSet(excludeGroupIds);</span><br><span class="line">        Set&lt;String&gt; skipArtifactIds = excludeArtifactIds == <span class="keyword">null</span> ? Collections.emptySet() : Sets.newHashSet(excludeArtifactIds);</span><br><span class="line">        Set&lt;String&gt; skipClassPrefixes = excludeClassPrefixes == <span class="keyword">null</span> ? Collections.emptySet() : Sets.newHashSet(excludeClassPrefixes);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; classArtifactIdMap = Maps.newHashMapWithExpectedSize(<span class="number">1024</span>);</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; classArtifactIdListMap = Maps.newHashMapWithExpectedSize(<span class="number">1024</span>);</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; classDistinctArtifactIdCountMap = Maps.newHashMapWithExpectedSize(<span class="number">1024</span>);</span><br><span class="line">        totalArtifactIds.forEach(item -&gt; &#123;</span><br><span class="line">            File file = item.getFile();</span><br><span class="line">            <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String groupId = item.getGroupId();</span><br><span class="line">            <span class="keyword">final</span> String artifactId = item.getArtifactId();</span><br><span class="line">            <span class="keyword">if</span> (skipArtifactIds.contains(artifactId) || skipCheckGroupIds.contains(groupId)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String gaItem = groupId + DuplicateClassConstants.COMMA_STR + artifactId;</span><br><span class="line">            String gavItem = gaItem + DuplicateClassConstants.COMMA_STR + item.getVersion();</span><br><span class="line">            List&lt;String&gt; classes = FileRetriever.getClassesFromPath(file);</span><br><span class="line">            <span class="keyword">for</span> (String foundClassItem : classes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isClassShouldSkip(foundClassItem, skipClassPrefixes)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (classArtifactIdMap.containsKey(foundClassItem)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> String lastGavItem = classArtifactIdMap.get(foundClassItem);</span><br><span class="line">                    <span class="keyword">if</span> (lastGavItem.equals(gavItem)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Set&lt;String&gt; existingGavItems = classArtifactIdListMap.getOrDefault(foundClassItem, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                    <span class="keyword">if</span> (existingGavItems.contains(gavItem)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    existingGavItems.add(lastGavItem);</span><br><span class="line">                    existingGavItems.add(gavItem);</span><br><span class="line">                    classArtifactIdListMap.put(foundClassItem, existingGavItems);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 同样的artifact但是version不一样的, 比如都是 fastjson, 可能有1.0 和 2.0</span></span><br><span class="line">                    String lastGaItem = getGaInfo(lastGavItem);</span><br><span class="line">                    Set&lt;String&gt; existingGaSet = classDistinctArtifactIdCountMap.getOrDefault(foundClassItem, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                    existingGaSet.add(gaItem);</span><br><span class="line">                    existingGaSet.add(lastGaItem);</span><br><span class="line">                    classDistinctArtifactIdCountMap.put(foundClassItem, existingGaSet);</span><br><span class="line">                &#125;</span><br><span class="line">                classArtifactIdMap.put(foundClassItem, gavItem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log(classArtifactIdListMap, classDistinctArtifactIdCountMap);</span><br><span class="line">        <span class="keyword">if</span> (!classArtifactIdListMap.isEmpty() &amp;&amp; failOnDuplicate) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MojoFailureException(DuplicateClassConstants.LOG_TAG + <span class="string">"there are classes existing in multiple artifact, please check!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isClassShouldSkip</span><span class="params">(String foundClassItem, Set&lt;String&gt; skipClassPrefixes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCollectionEmpty(skipClassPrefixes)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> skipClassPrefixes.stream().filter(StringUtils::isNotBlank).anyMatch(foundClassItem::startsWith);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; classArtifactIdListMap, Map&lt;String, Set&lt;String&gt;&gt; classDistinctArtifactIdCountMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classArtifactIdListMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getLog().warn(DuplicateClassConstants.LOG_TAG + <span class="string">"duplicate class size: "</span> + classArtifactIdListMap.keySet().size());</span><br><span class="line">        classArtifactIdListMap.forEach((classItem, artifactIds) -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; distinctGaItems = classDistinctArtifactIdCountMap.get(classItem);</span><br><span class="line">            <span class="keyword">if</span> (distinctGaItems.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Consumer&lt;String&gt; printFun = failOnDuplicate ? getLog()::error : getLog()::warn;</span><br><span class="line">                printDuplicateClassInfo(printFun, classItem, artifactIds);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDuplicateClassInfo(getLog()::warn, classItem, artifactIds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getGaInfo</span><span class="params">(String lastGavItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = lastGavItem.lastIndexOf(DuplicateClassConstants.COMMA_STR);</span><br><span class="line">        <span class="keyword">return</span> lastGavItem.substring(<span class="number">0</span>, lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printDuplicateClassInfo</span><span class="params">(Consumer&lt;String&gt; consumer, String classItem, Set&lt;String&gt; artifactIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String title = DuplicateClassConstants.LOG_TAG + <span class="string">"class["</span> + classItem + <span class="string">"] exist in following artifact:"</span>;</span><br><span class="line">        consumer.accept(title);</span><br><span class="line">        <span class="keyword">for</span> (String artifactId : artifactIds) &#123;</span><br><span class="line">            <span class="keyword">final</span> String content = <span class="string">"------------&gt;: "</span> + artifactId;</span><br><span class="line">            consumer.accept(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li>FileRetriever.java文件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRetriever</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassesFromPath</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getClassesFromDirectory(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getClassesFromJarFile(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 'com/demo/DuplicateClassFoundMojo' 转换成 "com.demo.DuplicateClassFoundMojo"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">fromFileToClassName</span><span class="params">(<span class="keyword">final</span> String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileName.replaceAll(<span class="string">"[/\\\\]"</span>, <span class="string">"\\."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassesFromJarFile</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (path.canRead()) &#123;</span><br><span class="line">                List&lt;String&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                JarFile jar = <span class="keyword">new</span> JarFile(path);</span><br><span class="line">                Enumeration&lt;JarEntry&gt; en = jar.entries();</span><br><span class="line">                <span class="keyword">while</span> (en.hasMoreElements()) &#123;</span><br><span class="line">                    JarEntry entry = en.nextElement();</span><br><span class="line">                    <span class="keyword">final</span> String name = entry.getName();</span><br><span class="line">                    <span class="keyword">if</span> (name.endsWith(DuplicateClassConstants.CLASS_FILE_SUFFIX) &amp;&amp; !name.endsWith(DuplicateClassConstants.MODULE_INFO_CLASS_SUFFIX)) &#123;</span><br><span class="line">                        String className = fromFileToClassName(name);</span><br><span class="line">                        classes.add(className);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> classes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(DuplicateClassConstants.LOG_TAG + <span class="string">"Failed to read classes from jar file: "</span> + path, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassesFromDirectory</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// get jar files from top-level directory</span></span><br><span class="line">        List&lt;File&gt; jarFiles = listFiles(path, (dir, name) -&gt; name.endsWith(DuplicateClassConstants.JAR_FILE_SUFFIX), <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (File file : jarFiles) &#123;</span><br><span class="line">            classes.addAll(getClassesFromJarFile(file));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get all class-files</span></span><br><span class="line">        List&lt;File&gt; classFiles = listFiles(path, (dir, name) -&gt; name.endsWith(DuplicateClassConstants.CLASS_FILE_SUFFIX), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> substringBeginIndex = path.getAbsolutePath().length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (File classfile : classFiles) &#123;</span><br><span class="line">            String className = classfile.getAbsolutePath().substring(substringBeginIndex);</span><br><span class="line">            className = fromFileToClassName(className);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classes.add(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">listFiles</span><span class="params">(File directory, FilenameFilter filter, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        File[] entries = directory.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (entries == <span class="keyword">null</span> || entries.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Go over entries</span></span><br><span class="line">        <span class="keyword">for</span> (File entry : entries) &#123;</span><br><span class="line">            <span class="comment">// If there is no filter or the filter accepts the</span></span><br><span class="line">            <span class="comment">// file / directory, add it to the list</span></span><br><span class="line">            <span class="keyword">if</span> (filter == <span class="keyword">null</span> || filter.accept(directory, entry.getName())) &#123;</span><br><span class="line">                files.add(entry);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the file is a directory and the recurse flag</span></span><br><span class="line">            <span class="comment">// is set, recurse into the directory</span></span><br><span class="line">            <span class="keyword">if</span> (recurse &amp;&amp; entry.isDirectory()) &#123;</span><br><span class="line">                files.addAll(listFiles(entry, filter, <span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Return collection of files</span></span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>
<br>



]]></content>
      <categories>
        <category>maven</category>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
</search>
