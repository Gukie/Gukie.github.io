<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTPS认证过程</title>
    <url>/2020/05/19/HTTPS%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><p>以下两篇文章对HTTPS解析的很详细，有图有真相，很好理解:</p>
<ul>
<li><a href="https://www.cnblogs.com/snowater/p/7804889.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowater/p/7804889.html</a></li>
<li><a href="https://www.cnblogs.com/xdyixia/p/11610102.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdyixia/p/11610102.html</a></li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>HTTPS是在HTTP跟TCP之间加了一层对数据进行加解密的SSL/TLS</p>
<ul>
<li>SSL: Secure Sockets Layer</li>
<li>TLS: Transport Layer Security</li>
</ul>
<p><br>HTTPS认证过程, 主要有三部分</p>
<ul>
<li>Server证书的认证阶段, 即得到CA机构的签名</li>
<li>Server跟Client之间通过非对称的方式验证彼此身份</li>
<li>Server跟Client之间通过双方认同的随机数做对称加密数据传输</li>
</ul>
<p><br><img src="https-1.svg" alt="证书的认证，以及HTTPS的工作流程.svg"></p>
]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类的初始化过程</title>
    <url>/2020/05/05/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<br>
<br>
<br>

<p><a name="atHd5"></a></p>
<h3 id="类的整个生命周期过程"><a href="#类的整个生命周期过程" class="headerlink" title="类的整个生命周期过程"></a>类的整个生命周期过程</h3><ul>
<li>加载</li>
<li>连接<ul>
<li>校验</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p><img src="/2020/05/05/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/linkage.png" alt="image.png"></p>
<br>
<br>

<p><a name="E8x6j"></a></p>
<h3 id="类创建过程主要分两步骤"><a href="#类创建过程主要分两步骤" class="headerlink" title="类创建过程主要分两步骤"></a>类创建过程主要分两步骤</h3><ul>
<li>类的加载过程, 本质上是在方法区生成类的Class对象，共其他地方引用使用</li>
<li>类的实例化</li>
</ul>
<p><a name="l282i"></a></p>
<h4 id="次序"><a href="#次序" class="headerlink" title="次序"></a>次序</h4><ul>
<li>次序是: 先自己的变量-&gt;父类-&gt;初始化</li>
<li>接口跟类不一样，接口只有在使用到的时候才会去初始化，而类即使没有使用到也会在它的子类初始化的时候被初始化出来</li>
</ul>
<p><a name="k5GKh"></a></p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>加载过程主要是对class的加载，不包含实例的初始化过程，所以操作的内存区域是方法区，这个过程主要包括：</p>
<ul>
<li>加载，将字节码文件加载到内存中来(比如从jar包中加载，从URL中加载)</li>
<li>连接(link)<ul>
<li>校验(verify): 校验字节码是否符合规范，比如<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>major/minor version是否是当前JVM支持的</li>
</ul>
</li>
<li>准备(prepare)，该阶段主要是给class的初始化做内存准备(静态变量)，比如<ul>
<li>为类变量(非实例变量)分配内存</li>
<li>为类变量赋予零值，比如int会给个0</li>
<li>对于final的类变量，这个阶段会直接给变量赋值而不是给初始值</li>
</ul>
</li>
<li>解析(resolve)，该阶段主要是解析该类引用的其他类，并将它们加载进来</li>
</ul>
</li>
<li>初始化<ul>
<li>对静态变量进行初始化</li>
<li>这个阶段会初始化静态变量和调用静态代码块</li>
<li>他们之间谁先谁后，取决于他们在源码中的先后顺序</li>
</ul>
</li>
</ul>
<br>

<p><a name="izS7T"></a></p>
<h4 id="实例的初始化过程"><a href="#实例的初始化过程" class="headerlink" title="实例的初始化过程"></a>实例的初始化过程</h4><ul>
<li>为实例变量分配内存，主要是堆中</li>
<li>给实例变量分配初始值</li>
<li>实例化父类</li>
<li>给实例变量赋予源码中的值, 调用实例块 (他们的先后顺序取决于他们在源码中的位置)</li>
<li>执行构造方法中剩余的代码</li>
</ul>
<br>

<p><a name="Yqlqk"></a></p>
<h3 id="实例创建的整个过程"><a href="#实例创建的整个过程" class="headerlink" title="实例创建的整个过程"></a>实例创建的整个过程</h3><p><img src="/2020/05/05/Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/process.svg" alt="类的初始化guocheng.svg"><br><br><br><br><br></p>
<p><a name="GYm9T"></a></p>
<h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p><a name="R8DyH"></a></p>
<h4 id="1-被动引用不会触发初始化"><a href="#1-被动引用不会触发初始化" class="headerlink" title="1. 被动引用不会触发初始化"></a>1. 被动引用不会触发初始化</h4><p>被动加载是相对主动加载来说的，主动加载是Java虚拟机规范中定义的几种类型:</p>
<ul>
<li>通过new/getstatic/putstatic/invokestatic指令触发的初始化</li>
<li>通过反射调用类的方法触发的初始化</li>
<li>在加载子类的时候，发现父类没有加载而触发的父类加载</li>
<li>调用类的main方法导致该类的初始化</li>
</ul>
<p><a name="iGhLB"></a></p>
<h5 id="1-1-通过子类引用父类的静态变量，不会导致子类的初始化"><a href="#1-1-通过子类引用父类的静态变量，不会导致子类的初始化" class="headerlink" title="1.1 通过子类引用父类的静态变量，不会导致子类的初始化"></a>1.1 通过子类引用父类的静态变量，不会导致子类的初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static block"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitializingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>以上代码只会初始化ParentClass，不会初始化SubClass. 输出的结果:<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parent Class static block</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<br>
<br>

<p><a name="X2MeK"></a></p>
<h5 id="1-2-通过数组定义来引用类，不会触发类的初始化"><a href="#1-2-通过数组定义来引用类，不会触发类的初始化" class="headerlink" title="1.2 通过数组定义来引用类，不会触发类的初始化"></a>1.2 通过数组定义来引用类，不会触发类的初始化</h5><p>数组的生成其实并没有生成数组元素的类，生成的是数组类, 比如 “[java.lang.Integer” 这样的类.<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static block"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitializingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SubClass[] subClasses = <span class="keyword">new</span> SubClass[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>运行之后发现，什么也没有输出，说明<code>SubClass[] subClasses = new SubClass[1];</code>跟 SubClass没有关系<br></p>
<p><a name="tcfKs"></a></p>
<h5 id="1-3-引用常量不会触发定义常量的类的初始化"><a href="#1-3-引用常量不会触发定义常量的类的初始化" class="headerlink" title="1.3 引用常量不会触发定义常量的类的初始化"></a>1.3 引用常量不会触发定义常量的类的初始化</h5><p>常量是只那些 final static的变量，这些变量会在准备阶段就初始化好，然后就会进入常量池里，之后其实就跟它所在的类没什么关系了. 后面其他类引用它的时候其实是从常量池中获取的.<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"constant class init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"kobe"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitializingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(ConstantClass.DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a name="sA9wT"></a></p>
<h3 id="2-父子类中override方法的执行"><a href="#2-父子类中override方法的执行" class="headerlink" title="2. 父子类中override方法的执行"></a>2. 父子类中override方法的执行</h3><p>当子类override了父类的方法的时候，在构造子类的实例阶段，父类调用的是子类的方法<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printThree();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"three"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> three = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(three);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">        subClass.printThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>输出的结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">SubClass Constructor</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这是因为在父类构造的时候，调用的是子类的printThree()，而此时three=0<br><br><br></p>
<p><a name="jVwYo"></a></p>
<h4 id="一个完整的实例构造例子"><a href="#一个完整的实例构造例子" class="headerlink" title="一个完整的实例构造例子"></a>一个完整的实例构造例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent Class instance block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> k = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printThree();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"three"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticBefore = staticP(<span class="string">"before"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticAfter = staticP(<span class="string">"after"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String instanceBefore = initK(<span class="string">"before"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass instance block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String instanceAfter = initK(<span class="string">"after"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> three = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticP</span><span class="params">(String i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static param: "</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubClass() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">initK</span><span class="params">(String j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"instance param:"</span> + j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(three);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line">        subClass.printThree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>输出的结果<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parent Class static block</span><br><span class="line">static param: before</span><br><span class="line">SubClass static block</span><br><span class="line">static param: after</span><br><span class="line">Parent Class instance block</span><br><span class="line">0</span><br><span class="line">instance param:before</span><br><span class="line">SubClass instance block</span><br><span class="line">instance param:after</span><br><span class="line">SubClass Constructor</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java运行时修改注解值</title>
    <url>/2020/11/14/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E5%80%BC/</url>
    <content><![CDATA[<p><a name="pNBxM"></a></p>
<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><ul>
<li><a href="https://blog.csdn.net/Crabime/article/details/54880411" target="_blank" rel="noopener">https://blog.csdn.net/Crabime/article/details/54880411</a></li>
<li><a href="https://blog.csdn.net/wanson2015/article/details/83993618" target="_blank" rel="noopener">https://blog.csdn.net/wanson2015/article/details/83993618</a></li>
</ul>
<br>
<br>在业务开发中，我们可能希望动态地修改注解中的值，以达到不同的处理效果.<br>
<br>注解:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BitPoint &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDataPoint</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@BitPoint</span>(order = <span class="number">1</span>, length = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BitPoint</span>(order = <span class="number">2</span>, length = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BitPoint</span>(order = <span class="number">3</span>, length = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>但是在业务发展过程中，中间那个userId字段一开始是1字节，后来1字节放不下了，需要2字节…那咋吧呢？其他业务逻辑都是一样的，就这个字段的长度变了。总不能再全写一套吧，虽然能实现，但是总感觉不优雅…<br><br><br>其实最好是在运行时进行annotation值的变更，网上找了资料之后，发现可以的。果然你遇到的问题别人都遇到过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationChange</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String byteStr = <span class="string">"01 00 01 01 02 03"</span>;</span><br><span class="line">        System.out.println(byteStr);</span><br><span class="line">        TestDataPoint dataPointRequest = DataPointUtils.fromRawValue(getBytes(byteStr), TestDataPoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(JSON.toJSONString(dataPointRequest));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Field field = FieldUtils.getDeclaredField(TestDataPoint.class,"userId",true);</span><br><span class="line">        BitPoint annotation = field.getAnnotation(BitPoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>)&#123;</span><br><span class="line">            InvocationHandler invocationHandler = Proxy.getInvocationHandler(annotation);</span><br><span class="line">            <span class="comment">// memberValues是固定的</span></span><br><span class="line">            Field values = invocationHandler.getClass().getDeclaredField(<span class="string">"memberValues"</span>);</span><br><span class="line">            values.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Map&lt;String, Object&gt; memberValues =(Map&lt;String, Object&gt;) values.get(invocationHandler);</span><br><span class="line">            <span class="keyword">int</span> val = (<span class="keyword">int</span>) memberValues.get(<span class="string">"length"</span>);</span><br><span class="line">            System.out.println(<span class="string">"before:"</span>  + val);</span><br><span class="line">            memberValues.put(<span class="string">"length"</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">"after:"</span>  + annotation.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"========="</span>);</span><br><span class="line">        TestDataPoint extDataPointRequest = DataPointUtils.fromRawValue(getBytes(byteStr), TestDataPoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(JSON.toJSONString(extDataPointRequest));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getBytes(String byteStr) &#123;</span><br><span class="line">        String [] items = StringUtils.split(byteStr,<span class="string">" "</span>);</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.stream(items).map(x -&gt; Integer.valueOf(x, <span class="number">16</span>)).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">byte</span>[] actualBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[items.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integers.size(); i++) &#123;</span><br><span class="line">            actualBytes[i] = integers.get(i).byteValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> actualBytes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 00 01 01 02 03</span><br><span class="line"></span><br><span class="line">&#123;&quot;type&quot;:1,&quot;userId&quot;:0,&quot;value&quot;:1&#125;</span><br><span class="line">before:1</span><br><span class="line">after:2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;&quot;type&quot;:1,&quot;userId&quot;:1,&quot;value&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p><br>上面代码唯一需要注意的是 获取 注解的feild的时候，memberValues是固定的, 原因如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field values = invocationHandler.getClass().getDeclaredField(<span class="string">"memberValues"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E5%80%BC/1.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>getResourceAsStream 在class和classloader的异同</title>
    <url>/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p><a name="6kO5S"></a></p>
<h3 id="Java中加载资源，有两种方式"><a href="#Java中加载资源，有两种方式" class="headerlink" title="Java中加载资源，有两种方式"></a>Java中加载资源，有两种方式</h3><ul>
<li>通过classloader的getResourceAsStream</li>
<li>通过class的getResourceAsStream</li>
</ul>
<br>
<br>他们的相同点，都是去resources下找资源，不同点是class的getResourceAsStream在找资源之前会对参数"name"进行处理。以下为源码的简单分析<br>
<br>

<p><a name="C0wO2"></a></p>
<h4 id="java-lang-ClassLoader-getResourceAsStream"><a href="#java-lang-ClassLoader-getResourceAsStream" class="headerlink" title="java.lang.ClassLoader#getResourceAsStream"></a>java.lang.ClassLoader#getResourceAsStream</h4><ul>
<li>name传什么，就用该name去找，不会做而外的处理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        URL url = getResource(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> url != <span class="keyword">null</span> ? url.openStream() : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><a name="tyQpQ"></a></p>
<h4 id="java-lang-Class-getResourceAsStream"><a href="#java-lang-Class-getResourceAsStream" class="headerlink" title="java.lang.Class#getResourceAsStream"></a>java.lang.Class#getResourceAsStream</h4><p>会先对传入的name做一层处理:</p>
<ul>
<li>如果name是以”/“为开头，那么不做处理，即: 从resources下找</li>
<li>如果name不是以”/“为开头，则会将 调用该方法的类的package加上去. 即会从resources下找”packageName”+”name”的资源. 比如”com.test.test-1.txt”</li>
</ul>
<p><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/1.png" alt="image.png"></p>
<ul>
<li>之后通过classloader去找资源<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        name = resolveName(name);</span><br><span class="line">        ClassLoader cl = getClassLoader0();</span><br><span class="line">        <span class="keyword">if</span> (cl==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A system class.</span></span><br><span class="line">            <span class="keyword">return</span> ClassLoader.getSystemResourceAsStream(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cl.getResourceAsStream(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a package name prefix if the name is not absolute Remove leading "/"</span></span><br><span class="line"><span class="comment">     * if name is absolute</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">resolveName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">while</span> (c.isArray()) &#123;</span><br><span class="line">                c = c.getComponentType();</span><br><span class="line">            &#125;</span><br><span class="line">            String baseName = c.getName();</span><br><span class="line">            <span class="keyword">int</span> index = baseName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">                name = baseName.substring(<span class="number">0</span>, index).replace(<span class="string">'.'</span>, <span class="string">'/'</span>)</span><br><span class="line">                    +<span class="string">"/"</span>+name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = name.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>
<br>

<p><a name="RvqPr"></a></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>在找不到资源的时候，可以查看下maven打出来的target中是否包含资源, 如果找得到，那就基本都能找到，否则就要看看pom.xml中是否在builder时候将对应的资源给exclude掉了(默认都是会将resources下的资源加载进来的)<br><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/2.png" alt="image.png"></p>
<p><a name="Oo89r"></a></p>
<h4 id="在main下的示例"><a href="#在main下的示例" class="headerlink" title="在main下的示例"></a>在main下的示例</h4><p>源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream fis1 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"hello.txt"</span>);</span><br><span class="line">        InputStream fis2 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"cloud_cert-daily.pfx"</span>);</span><br><span class="line">        InputStream fis3 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"cloud_root-daily.crt"</span>);</span><br><span class="line">        InputStream fis4 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"test.txt"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/3.png" alt="image.png"><br><a name="lLGB4"></a></p>
<h4 id="在test下进行的示例"><a href="#在test下进行的示例" class="headerlink" title="在test下进行的示例"></a>在test下进行的示例</h4><p>源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream fis1 = One.class.getClassLoader().getResourceAsStream("hello2.txt");</span><br><span class="line">        InputStream fis2 = One.class.getResourceAsStream("test-1.txt");</span><br><span class="line">        InputStream fis3 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"cert/pro/root-daily2.crt"</span>);</span><br><span class="line">        InputStream fis4 = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="string">"test2.txt"</span>);</span><br><span class="line">        InputStream fis5 = One.class.getResourceAsStream("/test3.txt");</span><br><span class="line">        InputStream fis6 = One.class.getResourceAsStream("/cert/pro/cert-daily1.pfx");</span><br><span class="line">        System.out.println(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/01/getResourceAsStream%20%E5%9C%A8class%E5%92%8Cclassloader%E7%9A%84%E5%BC%82%E5%90%8C/4.png" alt="image.png"><br><br><br></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>annotation定义的总结</title>
    <url>/2020/05/16/%5BAnnotation%5D%20annotation%E5%AE%9A%E4%B9%89%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Annotation-annotation定义的总结"><a href="#Annotation-annotation定义的总结" class="headerlink" title="[Annotation] annotation定义的总结"></a>[Annotation] annotation定义的总结</h1><p><a name="tyC3q"></a></p>
<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><ul>
<li><a href="https://juejin.im/post/5c63e2b0f265da2dd94c8e16" target="_blank" rel="noopener">https://juejin.im/post/5c63e2b0f265da2dd94c8e16</a> （@Inherited 使用注意点）</li>
</ul>
<br>
<br>


<table>
<thead>
<tr>
<th><strong>元注解</strong></th>
<th><strong>作用</strong></th>
<th><strong>使用注意点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@Inherited</td>
<td>是否可以继承. 即子类是否可以不用定义直接使用父类的注解</td>
<td>使用@Inherited注意点<br>- @Inherited 并不会从接口中继承，而只会从class中继承<br>- 方法并不从它所重载的方法继承annotation<br></td>
</tr>
<tr>
<td>@Retention</td>
<td>表示在系统运行的哪个阶段出现</td>
<td>RetentionPolicy.RUNTIME - 会被compiler记住并且会在JVM 运行时存留<br>RetentionPolicy.<em>CLASS - 会被compiler记住但是不会在JVM中存留</em></td>
</tr>
<tr>
<td>@Documented</td>
<td>是否在javadoc中出现</td>
<td></td>
</tr>
<tr>
<td>@Target</td>
<td>定义的注解可以使用在那些地方</td>
<td>具体可以查看 ElementType的定义<br>ElementType.<em>METHOD - 可以使用在方法上</em><br>ElementType.<em>TYPE - 可以使用在class/interface上</em></td>
</tr>
</tbody></table>
<p><br>一个完整的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>( &#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TimeTraceLog &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Level <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> Level.WARN</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>xml的 context:property-placeholder 的SpringBoot方式实现</title>
    <url>/2020/07/06/property-placeholder%E7%9A%84SpringBoot%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><br>当我们从配置中心读取配置信息的时候，通常会将读取配置中心的代码封装成一个bean. 然后将该bean赋予给PropertyPlaceHolder. <br></p>
<p><a name="CGtVZ"></a></p>
<h3 id="spring配置文件方式实现"><a href="#spring配置文件方式实现" class="headerlink" title="spring配置文件方式实现"></a>spring配置文件方式实现</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hulkConfigBean"</span> <span class="attr">class</span>=<span class="string">"com.xxx.config.MousikaPropertiesFactoryBean"</span> &gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"appName"</span> <span class="attr">value</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">properties-ref</span>=<span class="string">"hulkConfigBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MousikaPropertiesFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Properties</span>&gt;, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MousikaPropertiesFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Properties deployProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isInit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nameSpaces;</span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    List&lt;Config&gt; configs = <span class="keyword">new</span> ArrayList&lt;Config&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MousikaPropertiesFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Properties<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 这是 FactoryBean 获取bean时调用的方法，以下这种方式会调用更改犯法</span></span><br><span class="line"><span class="comment">    &lt;bean id="hulkConfigBean" class="com.xxx.config.MousikaPropertiesFactoryBean" &gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="appName" value="demo"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment"> 	&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isInit) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.isInit) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    Properties properties =    <span class="keyword">this</span>.getAppConfigFromApollo();</span><br><span class="line">                    <span class="keyword">this</span>.deployProperties.putAll(properties);</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">this</span>.isInit = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.deployProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppName</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appName = appName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Properties <span class="title">getAppConfigFromApollo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 从配置中心获取配置信息</span></span><br><span class="line">        configs.add(getConfigFromRemote())</span><br><span class="line">        <span class="keyword">if</span> (configs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Config config : configs) &#123;</span><br><span class="line">                properties.putAll(config.getAllProperties());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a name="Sqhpj"></a></p>
<h3 id="运行机制解析"><a href="#运行机制解析" class="headerlink" title="运行机制解析"></a>运行机制解析</h3><p><a name="C4jzH"></a></p>
<h4 id="xml文件设置过程"><a href="#xml文件设置过程" class="headerlink" title="xml文件设置过程"></a>xml文件设置过程</h4><p>Spring在启动的时候，会解析xml文件，是</p>
<ul>
<li>通过org.springframework.context.config.PropertyPlaceholderBeanDefinitionParser进行解析</li>
<li>然后将属性设置在org.springframework.context.support.PropertySourcesPlaceholderConfigurer中<br><br><img src="/2020/07/06/property-placeholder%E7%9A%84SpringBoot%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0/1.png" alt="image.png"><br><br>
</li>
</ul>
<ol>
<li>解析xml <code>&lt;context:property-placeholder properties-ref=&quot;configBean&quot;/&gt;</code> 的代码是<br>代码位置: org.springframework.context.config.AbstractPropertyLoadingBeanDefinitionParser#doParse<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		String propertiesRef = element.getAttribute(<span class="string">"properties-ref"</span>);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">			builder.addPropertyReference(<span class="string">"properties"</span>, propertiesRef);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>将beanName以RuntimeBeanReference的形式包装起来:<br>代码位置： org.springframework.beans.factory.support.BeanDefinitionBuilder#addPropertyReference<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">addPropertyReference</span><span class="params">(String name, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里将beanName以 RuntimeBeanReference包装起来</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinition.getPropertyValues().add(name, <span class="keyword">new</span> RuntimeBeanReference(beanName));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><a name="HOAvi"></a></p>
<h4 id="propertyValue数据读取与设置"><a href="#propertyValue数据读取与设置" class="headerlink" title="propertyValue数据读取与设置"></a>propertyValue数据读取与设置</h4><p><br>在处理 org.springframework.context.config.PropertyPlaceholderBeanDefinitionParser 的时候，会通过以下代码进行处理<br></p>
<ol>
<li>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyPropertyValues<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">				deepCopy.add(pv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String propertyName = pv.getName();</span><br><span class="line">				Object originalValue = pv.getValue();</span><br><span class="line">                <span class="comment">// 这里会去获取 hulkConfigBean 的bean对象. 通过上文可知获取到的是一个Properties</span></span><br><span class="line">				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">				...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/07/06/property-placeholder%E7%9A%84SpringBoot%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0/2.png" alt="image.png"></li>
<li>org.springframework.beans.factory.support.BeanDefinitionValueResolver#resolveValueIfNecessary<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, Object value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// We must check each value to see whether it requires a runtime reference</span></span><br><span class="line">		<span class="comment">// to another bean to be resolved.</span></span><br><span class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">			RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">			<span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">		&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String refName = ref.getBeanName();</span><br><span class="line">			refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">			<span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.getParentBeanFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">							<span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">							<span class="string">"Can't resolve reference to bean '"</span> + refName +</span><br><span class="line">							<span class="string">"' in parent factory: no parent factory available"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 会走到这里，然后获取hulkConfigBean的内容(一个properties)</span></span><br><span class="line">				Object bean = <span class="keyword">this</span>.beanFactory.getBean(refName);</span><br><span class="line">				<span class="keyword">this</span>.beanFactory.registerDependentBean(refName, <span class="keyword">this</span>.beanName);</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					<span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,</span><br><span class="line">					<span class="string">"Cannot resolve reference to bean '"</span> + ref.getBeanName() + <span class="string">"' while setting "</span> + argName, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>

<p><a name="g5zNs"></a></p>
<h3 id="SpringBoot-等价写法"><a href="#SpringBoot-等价写法" class="headerlink" title="SpringBoot 等价写法"></a>SpringBoot 等价写法</h3><p>不采用xml的方式，使用编程的方式的写法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonMemBizConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MousikaPropertiesFactoryBean <span class="title">hulkConfigBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MousikaPropertiesFactoryBean item = <span class="keyword">new</span> MousikaPropertiesFactoryBean();</span><br><span class="line">        item.setAppName(<span class="string">"demo"</span>);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertySourcesPlaceholderConfigurer <span class="title">propertySourcesPlaceholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            propertySourcesPlaceholderConfigurer.setProperties(hulkConfigBean().getObject());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> propertySourcesPlaceholderConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 中的logback环境隔离</title>
    <url>/2020/10/22/spring-boot%20%E4%B8%AD%E7%9A%84logback%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<p><a name="b2tSi"></a></p>
<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><ul>
<li><a href="https://www.cnblogs.com/easonjim/p/7801549.html" target="_blank" rel="noopener">https://www.cnblogs.com/easonjim/p/7801549.html</a></li>
<li><a href="http://logback.qos.ch/manual/filters.html" target="_blank" rel="noopener">http://logback.qos.ch/manual/filters.html</a>（自定义logback filter）</li>
<li><a href="https://docs.spring.io/spring-boot/docs/1.5.7.RELEASE/reference/htmlsingle/#boot-features-custom-log-configuration" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.7.RELEASE/reference/htmlsingle/#boot-features-custom-log-configuration</a> （spring关于日志的环境隔离的官网文档，你想要的这里都有）</li>
</ul>
<br>
<br>不同环境需要不同的日志输出，比如dev环境希望在启动的时候输出一些内容到console，提示是否启动成功了. 但是在其他环境上就没有必要输出到console了。所以这里就需要按环境区分对待了<br>
<br>
<br>由于各个服务采用的框架不同，不一定都是springboot. 所以在运维部署时并没有统一使用 spring.profiles.active进行环境隔离，而是使用自定义的环境变量进行隔离，比如 `-Denv=dev`<br>
<br>所以一开始想到的是自定义logback的filter进行处理
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomLogFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String targetEnv;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以逗号分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String targetClasses;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetEnv</span><span class="params">(String targetEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetEnv = targetEnv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetClasses</span><span class="params">(String targetClasses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetClasses = targetClasses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterReply <span class="title">decide</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        String currEnv = System.getProperty(<span class="string">"env"</span>);</span><br><span class="line">        String currClassName = event.getLoggerName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> classNameMatched = isClassNameMatched(currClassName);</span><br><span class="line">        <span class="keyword">boolean</span> envMatched = StringUtils.isBlank(targetEnv) || StringUtils.equals(targetEnv, currEnv);</span><br><span class="line">        <span class="keyword">if</span> (envMatched &amp;&amp; classNameMatched) &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.ACCEPT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FilterReply.DENY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isClassNameMatched</span><span class="params">(String currClassName)</span> </span>&#123;</span><br><span class="line">        String[] targetClasses = StringUtils.split(<span class="keyword">this</span>.targetClasses, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetClasses == <span class="keyword">null</span> || targetClasses.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(targetClasses).contains(currClassName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>后来同事给的建议说是使用springProfile可以达到此目的. 仔细想了下，在开发环境上如果想要将一些信息输出到console，则开发人员必须设置spring.profiles.active=dev，因为springboot中spring.profiles.active的值默认是default的。 所以觉得该方案挺不错的，即在logback的配置文件中加入springProfile

<p>一开始是这样的:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"InfoFile"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"WarnFile"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ErrorFile"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"InfoFile"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"WarnFile"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ErrorFile"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 后来再调整成了以下形式，更加简洁了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"InfoFile"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"WarnFile"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ErrorFile"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><br>最终的logback-spring.xml如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"loggingRoot"</span> <span class="attr">source</span>=<span class="string">"logging.path"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">				%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;, %L, %logger&#123;300&#125; %M %m%n</span><br><span class="line">            ]]&gt;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"com.xxx.MyCustomLogFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetEnv</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">targetEnv</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetClasses</span>&gt;</span>com.xxx.Startup<span class="tag">&lt;/<span class="name">targetClasses</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"InfoFile"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;loggingRoot&#125;/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;loggingRoot&#125;/info_%d&#123;yyyy-MM-dd.HH&#125;.log</span><br><span class="line">			<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>7<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"InfoFile"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"WarnFile"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ErrorFile"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>springboot</category>
        <category>logback</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo反序列化为什么需要默认构造函数</title>
    <url>/2020/08/21/Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><br>最近发现一个问题，在提供的dubbo服务中，如果对参数校验失败抛出异常对时候，在consumer端进行反序列化时会失败. 错误如下:<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.alibaba.com.caucho.hessian.io.HessianProtocolException: &#39;com.xxx.client.exception.BizException&#39; could not be instantiated</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.JavaDeserializer.instantiate(JavaDeserializer.java:316)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.JavaDeserializer.readObject(JavaDeserializer.java:201)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.SerializerFactory.readObject(SerializerFactory.java:536)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObjectInstance(Hessian2Input.java:2820)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObject(Hessian2Input.java:2743)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObject(Hessian2Input.java:2278)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObject(Hessian2Input.java:2717)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.Hessian2Input.readObject(Hessian2Input.java:2278)</span><br><span class="line">	at org.apache.dubbo.common.serialize.hessian2.Hessian2ObjectInput.readObject(Hessian2ObjectInput.java:85)</span><br><span class="line">	at org.apache.dubbo.rpc.protocol.dubbo.DecodeableRpcResult.handleException(DecodeableRpcResult.java:144)</span><br><span class="line">	at org.apache.dubbo.rpc.protocol.dubbo.DecodeableRpcResult.decode(DecodeableRpcResult.java:96)</span><br><span class="line">	at org.apache.dubbo.rpc.protocol.dubbo.DecodeableRpcResult.decode(DecodeableRpcResult.java:112)</span><br><span class="line">	at org.apache.dubbo.rpc.protocol.dubbo.DubboCodec.decodeBody(DubboCodec.java:92)</span><br><span class="line">	at org.apache.dubbo.remoting.exchange.codec.ExchangeCodec.decode(ExchangeCodec.java:122)</span><br><span class="line">	at org.apache.dubbo.remoting.exchange.codec.ExchangeCodec.decode(ExchangeCodec.java:82)</span><br><span class="line">	at org.apache.dubbo.rpc.protocol.dubbo.DubboCountCodec.decode(DubboCountCodec.java:48)</span><br><span class="line">	at org.apache.dubbo.remoting.transport.netty4.NettyCodecAdapter$InternalDecoder.decode(NettyCodecAdapter.java:90)</span><br><span class="line">	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:502)</span><br><span class="line">	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:441)</span><br><span class="line">	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:278)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)</span><br><span class="line">	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span><br><span class="line">	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span><br><span class="line">	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)</span><br><span class="line">	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:644)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:579)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:496)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:458)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:897)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">	at com.alibaba.com.caucho.hessian.io.JavaDeserializer.instantiate(JavaDeserializer.java:312)</span><br><span class="line">	... 34 more</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">	at com.xxx.client.exception.BizException.&lt;init&gt;(BizException.java:24)</span><br><span class="line">	... 39 more</span><br><span class="line"></span><br><span class="line">	at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:117)</span><br><span class="line">	at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:248)</span><br><span class="line">	at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:78)</span><br><span class="line">	at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:55)</span><br><span class="line">	at org.apache.dubbo.common.bytecode.proxy31.add(proxy31.java)</span><br><span class="line">	... 12 more</span><br></pre></td></tr></table></figure>

<br>
<br>BizException的代码如下:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(LangIEnum enums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(enums.getKey(), enums.getCnDesc());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(BizExceptionCode bizExceptionCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bizExceptionCode.getCode(),bizExceptionCode.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(String code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(code,message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Object[] getParams() &#123;</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(Object[] params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.params = params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>业务代码如下:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(UserDevicePropertyDTO userDeviceProperty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (userDeviceProperty == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(BizExceptionCode.PARAM_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><a name="JbYu7"></a></p>
<h3 id="代码简析"><a href="#代码简析" class="headerlink" title="代码简析"></a>代码简析</h3><p>从业务代码角度看，没有任何毛病。但从报错信息看是在构造BizException的时候，入参为null, 从而导致NPE了. 可是传的明明是 BizExceptionCode.PARAM_INVALID，见鬼了吗? 仔细分析之后会发现，BizExceptionCode的构造方法的入参确实是null, 具体过程如下<br><br><br><br><br>1.代码位置: com.alibaba.com.caucho.hessian.io.JavaDeserializer#JavaDeserializer<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JavaDeserializer</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Constructor[] constructors = cl.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">long</span> bestCost = Long.MAX_VALUE;</span><br><span class="line">		<span class="comment">// 根据构造函数的参数计算cost，并取最小的那个. 如果有无参构造函数，则其cost最小.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">            Class[] param = constructors[i].getParameterTypes();</span><br><span class="line">            <span class="keyword">long</span> cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; param.length; j++) &#123;</span><br><span class="line">                cost = <span class="number">4</span> * cost;</span><br><span class="line"></span><br><span class="line">                if (Object.class.equals(param[j]))</span><br><span class="line">                    cost += <span class="number">1</span>;</span><br><span class="line">                else if (String.class.equals(param[j]))</span><br><span class="line">                    cost += <span class="number">2</span>;</span><br><span class="line">                else if (int.class.equals(param[j]))</span><br><span class="line">                    cost += <span class="number">3</span>;</span><br><span class="line">                else if (long.class.equals(param[j]))</span><br><span class="line">                    cost += <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (param[j].isPrimitive())</span><br><span class="line">                    cost += <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cost += <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cost &lt; <span class="number">0</span> || cost &gt; (<span class="number">1</span> &lt;&lt; <span class="number">48</span>))</span><br><span class="line">                cost = <span class="number">1</span> &lt;&lt; <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">            cost += (<span class="keyword">long</span>) param.length &lt;&lt; <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cost &lt; bestCost) &#123;</span><br><span class="line">                _constructor = constructors[i];</span><br><span class="line">                bestCost = cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_constructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            _constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Class[] params = _constructor.getParameterTypes();</span><br><span class="line">            _constructorArgs = <span class="keyword">new</span> Object[params.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取构造函数的入参</span></span><br><span class="line">                _constructorArgs[i] = getParamArg(params[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a map of the classes fields.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title">getParamArg</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前类不是基础类型，则会返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!cl.isPrimitive())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">Boolean</span>.<span class="title">FALSE</span></span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">byte</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">new</span> <span class="title">Byte</span>((<span class="title">byte</span>) 0)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">short</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">new</span> <span class="title">Short</span>((<span class="title">short</span>) 0)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">char</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">new</span> <span class="title">Character</span>((<span class="title">char</span>) 0)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">Integer</span>.<span class="title">valueOf</span>(0)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">long</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">Long</span>.<span class="title">valueOf</span>(0)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">float</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">Float</span>.<span class="title">valueOf</span>(0)</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">double</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cl</span>))</span></span><br><span class="line"><span class="class">            <span class="title">return</span> <span class="title">Double</span>.<span class="title">valueOf</span>(0)</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>
<br>从以上代码可以看出

<ul>
<li>由于BizException没有无参构造函数，所以cost最小的是只有一个入参的。从Class.getDeclaredConstructors()返回的列表看，第一个只有一个入参的构造函数是BizException(BizExceptionCode bizExceptionCode)</li>
</ul>
<p><img src="/2020/08/21/Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/1.png" alt="image.png"></p>
<ul>
<li>由于BizExceptionCode不是基础类型，所以在getParamArg时返回了null</li>
</ul>
<br>
<br>
<br>所以在构造时候,  使用传入的参数去获取数据时，就NPE。<br>源码如下:com.alibaba.com.caucho.hessian.io.JavaDeserializer#instantiate
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_constructor != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> _constructor.newInstance(_constructorArgs);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> _type.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HessianProtocolException(<span class="string">"'"</span> + _type.getName() + <span class="string">"' could not be instantiated"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(BizExceptionCode bizExceptionCode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造的时候， bizExceptionCode为null， 所以这里会报NPE</span></span><br><span class="line">    <span class="keyword">super</span>(bizExceptionCode.getCode(),bizExceptionCode.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>
<br>

<p><a name="2Dkaf"></a></p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>从反序列化时，选择构造函数的算法中可以知道，如果我们有一个默认构造器, 那么它将会被选中. 从而不会出现上述问题. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>有了默认构造器之后，后面反序列化器会将数据设置到相应的field，从而完成反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">(AbstractHessianInput in, String[] fieldNames)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化</span></span><br><span class="line">         Object obj = instantiate();</span><br><span class="line"><span class="comment">// 从input中读取数据，其中fieldNames则是类中的所有fieldNames</span></span><br><span class="line">         <span class="keyword">return</span> readObject(in, obj, fieldNames);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IOExceptionWrapper(_type.getName() + <span class="string">":"</span> + e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p><a name="ibk7Q"></a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无参构造函数在很多地方都会有使用到，比如Spring的bean的初始化。 这里则是dubbo的序列化上。所以在编写代码的时候尽量提供无参构造函数，以免增加不必要的烦恼</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis Interceptor使用</title>
    <url>/2020/05/23/Mybatis%20Interceptor%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="为什么Interceptor只能是固定的几种类型"><a href="#为什么Interceptor只能是固定的几种类型" class="headerlink" title="为什么Interceptor只能是固定的几种类型"></a>为什么Interceptor只能是固定的几种类型</h3><p><br>首先，interceptor中的类型，目前只有以下四种才能生效:</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<br>
<br>不能自定义，因为这样是找不到的，比如以下这种自定义的 LockPwdDAO.class 是找不到的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(</span><br><span class="line">        &#123;<span class="meta">@Signature</span>(type = LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"save"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"add"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"update"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"add"</span>, args = &#123;List<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"update"</span>, args = &#123;List<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                @<span class="title">Signature</span>(<span class="title">type</span> </span>= LockPwdDAO<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"updateByIds"</span>, args = &#123;BaseDO<span class="class">.<span class="keyword">class</span>&#125;)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TimeStampTransferInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>这是因为org.apache.ibatis.plugin.Plugin#wrap中会做校验，不是规范的类，是不会被处理的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">	<span class="comment">// 这里出来是空的</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">          <span class="comment">// 因为我们自定义的类，在这里是不会为true的. 因为c是: Executor,ParameterHandler, ResultSetHandler,StatementHandler 中的一个</span></span><br><span class="line">        <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><br>可以通过查看 org.apache.ibatis.plugin.Plugin#getSignatureMap 的调用链获取更详细的信息<br><img src="/2020/05/23/Mybatis%20Interceptor%E4%BD%BF%E7%94%A8/invoke-chain.png" alt="image.png"><br><br><br>org.apache.ibatis.plugin.InterceptorChain#pluginAll的入参是传入的，也就是 Executor/ ParameterHandler/ResultSetHandler/ StatementHandler 中的一个，知道这个之后@Intercepts的@Signature中的method也就知道怎么配置就一目了然了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>以下是 org.apache.ibatis.session.Configuration#newParameterHandler 的代码摘要:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<p><a name="hL9hH"></a></p>
<h3 id="最终可用代码示例"><a href="#最终可用代码示例" class="headerlink" title="最终可用代码示例"></a>最终可用代码示例</h3><p><br>以下的目的是: 对时间的统一处理，以免有的人用的时候传的13位(毫秒)，有的人使用的时候传的是10位，即秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Intercepts</span>( &#123;</span><br><span class="line">        <span class="meta">@Signature</span>(type = Executor<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"update"</span>, args = &#123;MappedStatement<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TimeStampTransferInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String targetStatementIdPrefix = <span class="string">"com.xxx.dao.yyy.impl.LockPwdDAO"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; targetMethod = Arrays.asList(<span class="string">"save"</span>, <span class="string">"add"</span>, <span class="string">"update"</span>, <span class="string">"batchUpdate"</span>, <span class="string">"updateByIds"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) args[<span class="number">0</span>];</span><br><span class="line">        Object param = args[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handleEffectiveInvalidTimeSet(mappedStatement, param);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"[time-stamp-interceptor] "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleEffectiveInvalidTimeSet</span><span class="params">(MappedStatement mappedStatement, Object param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// param</span></span><br><span class="line">        String mappedStatementId = mappedStatement.getId();</span><br><span class="line">        <span class="keyword">boolean</span> isTargetMethod = isTargetStatement(mappedStatementId);</span><br><span class="line">        <span class="keyword">if</span> (!isTargetMethod) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"[time-stamp-interceptor] fix effective/invalid time"</span> );</span><br><span class="line">        <span class="keyword">if</span> (param <span class="keyword">instanceof</span> LockPwdDO) &#123;</span><br><span class="line">            LockPwdDO lockPwd = (LockPwdDO) param;</span><br><span class="line">            updateEffectiveInvalidTime2Second(lockPwd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// see: org.apache.ibatis.session.defaults.DefaultSqlSession.wrapCollection</span></span><br><span class="line">        <span class="keyword">if</span> (param <span class="keyword">instanceof</span> DefaultSqlSession.StrictMap) &#123;</span><br><span class="line">            DefaultSqlSession.StrictMap strictMap= (DefaultSqlSession.StrictMap) param;</span><br><span class="line">            List&lt;LockPwdDO&gt; lockPwds = (List&lt;LockPwdDO&gt;) strictMap.get(<span class="string">"list"</span>);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(lockPwds)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (LockPwdDO lockPwd : lockPwds) &#123;</span><br><span class="line">                updateEffectiveInvalidTime2Second(lockPwd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTargetStatement</span><span class="params">(String mappedStatementId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isLockPwdStatement = StringUtils.startsWith(mappedStatementId, targetStatementIdPrefix);</span><br><span class="line">        <span class="keyword">if</span> (!isLockPwdStatement) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastDotIndex = targetStatementIdPrefix.length() + <span class="number">1</span>;</span><br><span class="line">        String method = mappedStatementId.substring(lastDotIndex);</span><br><span class="line">        <span class="keyword">return</span> targetMethod.contains(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateEffectiveInvalidTime2Second</span><span class="params">(LockPwdDO lockPwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lockPwd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long originalEffectiveTime = lockPwd.getEffectiveTime();</span><br><span class="line">        Long originalInvalidTime = lockPwd.getInvalidTime();</span><br><span class="line">        lockPwd.setEffectiveTime(format2FixedLength(originalEffectiveTime, <span class="number">10</span>));</span><br><span class="line">        lockPwd.setInvalidTime(format2FixedLength(originalInvalidTime, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">format2FixedLength</span><span class="params">(Long originalTime, <span class="keyword">int</span> targetLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (originalTime == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> originalTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> currLength = originalTime.toString().length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diffLen = targetLength - currLength;</span><br><span class="line">        <span class="keyword">if</span> (diffLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> originalTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> factor = Math.pow(<span class="number">10</span>, Math.abs(diffLen));</span><br><span class="line">        <span class="keyword">if</span> (diffLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Double tmp = originalTime / factor;</span><br><span class="line">            <span class="keyword">return</span> tmp.longValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diffLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Double tmp = originalTime * factor;</span><br><span class="line">            <span class="keyword">return</span> tmp.longValue();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> originalTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>定义好之后，需要将interceptor注入进 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.xxx.entity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath*:conf/mybatis/*.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"plugins"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lockPwdInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.xxx.interceptor.TimeStampTransferInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="多个interceptor的执行顺序"><a href="#多个interceptor的执行顺序" class="headerlink" title="多个interceptor的执行顺序"></a>多个interceptor的执行顺序</h3><p><br>定义在后面的会先执行。 以下定义中，<code>interceptor1</code> 会在 <code>interceptor2</code>之前执行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"plugins"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"com.tuya.hulk.dal.interceptor.Interceptor2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"com.tuya.hulk.dal.interceptor.Interceptor1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><br>执行的时候，是以以下顺序进行执行的<img src="/2020/05/23/Mybatis%20Interceptor%E4%BD%BF%E7%94%A8/interceptor-invoke-sequence.jpg" alt="interceptor-invoke-sequence.jpg"><br><br><br>所以在xml定义中的最后一个interceptor会被第一个执行，但是却最后一个执行完(因为要等其他interceptor执行完之后它才能结束)，所以可以在该Interceptor上做一些统一的处理(比如Exception的兜底处理，时间的统计等), 类似:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 统一的异常处理</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><br>那为什么执行顺序是这样的呢？<br>从 <code>org.apache.ibatis.plugin.InterceptorChain#pluginAll</code> 中可以找到答案:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 答案在这里</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>首先， 给 target 做plugin的时候，是按照 interceptors的顺序进行的，也就是按照interceptor在xml中的定义进行的</li>
<li>最上面的，先进行 <code>target = interceptor.plugin(target);</code> 后面的后进行</li>
<li>我们注意到  <code>interceptor.plugin(target);</code> 执行完之后是会将结果覆盖掉 target的，即每做一次 拦截器的plugin，target都是会变更的. 所以<ol>
<li>拦截器1 被插入到target</li>
<li>之后拦截器2再插进去</li>
<li>再之后是拦截器3</li>
<li>这样就形成像将羽毛球放入桶里一样，先进去的在最底下后进去的在最上面这样的队形:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拦截器3--&gt;拦截器2--&gt;拦截器1</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<ol start="4">
<li>所以在执行的时候，是在最上面的先进行执行, 即 拦截器3</li>
</ol>
]]></content>
      <categories>
        <category>mybatis</category>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的BeanFactory.getBeansOfType的坑</title>
    <url>/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p><a name="MojXv"></a></p>
<h3 id="背景及问题发现"><a href="#背景及问题发现" class="headerlink" title="背景及问题发现"></a>背景及问题发现</h3><p>有时候，我们会在spring的bean实例化之前做一些校验，比如校验某些package下的类的命名是否符合规范，此时就会去实现 BeanDefinitionRegistryPostProcessor 做一些事情<br><br><br>我们假设，我们需要校验的类都实现了一个interface，名叫: IProxyBaseService， 那么我们很自然的就会有以下思路</p>
<ul>
<li>获取所有 IProxyBaseService的bean的定义</li>
<li>通过该bean找到对应的class，然后通过反射校验他们的方法是否合规</li>
</ul>
<p><br>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, IProxyBaseService&gt; nameInstanceMap = beanFactory.getBeansOfType(IProxyBaseService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(nameInstanceMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nameInstanceMap.forEach((beanName, beanInstance) -&gt; &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfacesAsSet(beanInstance);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(interfaces)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; interfaceCls : interfaces) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ClassUtils.isAssignable(IProxyBaseService<span class="class">.<span class="keyword">class</span>, <span class="title">interfaceCls</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkInterfaceMethods(interfaceCls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><br>如果系统中使用了dubbo，那么坑就来了: 当果你的dubbo的配置是通过占位符来做的，那么你将获取不到对应占位符的值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"$&#123;zookeeper.address&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后报以下错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: zookeeper not connected</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient.&lt;init&gt;(CuratorZookeeperClient.java:83)</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter.createZookeeperClient(CuratorZookeeperTransporter.java:26)</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.support.AbstractZookeeperTransporter.connect(AbstractZookeeperTransporter.java:68)</span><br><span class="line">    at org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter$Adaptive.connect(ZookeeperTransporter$Adaptive.java)</span><br><span class="line">    at org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfiguration.&lt;init&gt;(ZookeeperDynamicConfiguration.java:62)</span><br><span class="line">    at org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory.createDynamicConfiguration(ZookeeperDynamicConfigurationFactory.java:37)</span><br></pre></td></tr></table></figure>

<p><br>这时候如果没有认真debug过，会认为zk链接不上了，然后把问题指向zk，从而偏离了问题的本质<br></p>
<p><a name="MERTr"></a></p>
<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><p>从报错看，我们可以讲断点放在 <code>CuratorZookeeperClient.java:83</code>， 然后会发现，此时的地址都是占位符的<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-1.png" alt="image.png"><br><br><br>此时我们可以将我们自己写的代码注释掉，看看结果是什么样的，会发现其实是有值的，那么可以断定是代码的问题<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-2.png" alt="image.png"><br><br><br><br><br><br><br>经过排查，发现这一行代码有问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, IProxyBaseService&gt; nameInstanceMap = beanFactory.getBeansOfType(IProxyBaseService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>该代码会去找IProxyBaseService类的bean，但是它是使用了缺省参数的方法:<br>org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeansOfType<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-3.png" alt="image.png"><br><br><br>再往下会发现<br>org.springframework.beans.factory.support.DefaultListableBeanFactory#doGetBeanNamesForType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的 allowEagerInit 会让条件为true</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">        (mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">                !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">    <span class="keyword">boolean</span> isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">    BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">    <span class="keyword">boolean</span> matchFound =</span><br><span class="line">            (allowEagerInit || !isFactoryBean ||</span><br><span class="line">                    (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">            (includeNonSingletons ||</span><br><span class="line">                    (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">        <span class="comment">// 会进入到这里去  </span></span><br><span class="line">        isTypeMatch(beanName, type);</span><br><span class="line">    <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">        <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line">        beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">        matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">        result.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>然后会进入到<br>org.springframework.beans.factory.support.AbstractBeanFactory#isTypeMatch的以下代码段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里会校验当前类是否是FactoryBean</span></span><br><span class="line"><span class="keyword">if</span> (FactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanType</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="comment">// If it's a FactoryBean, we want to look at what it creates, not the factory class.</span></span><br><span class="line">        beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-4.png" alt="image.png"><br>而org.apache.dubbo.config.spring.ReferenceBean 正好是一个FactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>这样就会尝试去实例化ReferenceBean了，最后就会走到org.apache.dubbo.config.spring.ReferenceBean#afterPropertiesSet， 由于现在还只是在BeanDefinition处理阶段，还并没有到占位符的设置阶段，所以是读取不到占位符的值的，所以它还是原来的模样: ${zookeeper.address}, 并没有变形<br>
<br>

<p><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-5.png" alt="image.png"></p>
<p><a name="up6HB"></a></p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>知道问题的原因了: beanFactory.getBeansOfType的参数allowEagerInit=true时会将FactoryBean初始化掉。<br>所以改起来也很简单，就是使用另外一个方法:<br><code>beanFactory.getBeansOfType(IProxyBaseService.class,false, false);</code><br><br><br>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, IProxyBaseService&gt; nameInstanceMap = beanFactory.getBeansOfType(IProxyBaseService<span class="class">.<span class="keyword">class</span>,<span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(nameInstanceMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nameInstanceMap.forEach((beanName, beanInstance) -&gt; &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfacesAsSet(beanInstance);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(interfaces)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; interfaceCls : interfaces) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ClassUtils.isAssignable(IProxyBaseService<span class="class">.<span class="keyword">class</span>, <span class="title">interfaceCls</span>)) </span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkInterfaceMethods(interfaceCls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><a name="LfS6k"></a></p>
<h3 id="事情还在继续"><a href="#事情还在继续" class="headerlink" title="事情还在继续"></a>事情还在继续</h3><p><br>然而事情并没有那么简单，在后面的测试中，会发现，实现了IProxyBaseService的类，其field都是null.<br><img src="/2020/05/07/Spring%E7%9A%84BeanFactory.getBeansOfType%E7%9A%84%E5%9D%91/spring-6.png" alt="image.png"><br><br><br>这很严重啊。既然是都为空，那么看看它是什么时候进行初始化的，然后找了一个类，在其后面加了个InitializingBean进行断点调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceProxyServiceImpl</span> <span class="keyword">implements</span> <span class="title">IDeviceProxyService</span>, <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>debug后，发现这是从 beanFactory.getBeansOfType(IProxyBaseService.class,false, false); 调用过来的。<br>代码如下: org.springframework.beans.factory.support.DefaultListableBeanFactory#getBeansOfType<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.这一行，是FactoryBean初始化的问题的根源</span></span><br><span class="line">        String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, T&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, T&gt;(beanNames.length);</span><br><span class="line">        <span class="comment">// 2.可是事情并没有完，当找出了IProxyBaseService这个类的beanName之后，就到了这</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 这里有一个getBean，然后就会去创建bean. 而此时bean都还没有实例化出来，所以都是null </span></span><br><span class="line">                result.put(beanName, getBean(beanName, type));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><br>解决方法是, 不使用beanFactory.getBeansOfType， 而是使用BeanDefinitionRegistry去获取对应的beanName，然后找到对应的class做自己的业务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       String[] beanNames = registry.getBeanDefinitionNames();</span><br><span class="line">       <span class="keyword">if</span> (beanNames == <span class="keyword">null</span> || beanNames.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">           BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);</span><br><span class="line">           String beanClsName = beanDefinition.getBeanClassName();</span><br><span class="line">           <span class="keyword">if</span> (!StringUtils.contains(beanClsName, <span class="string">"com.xxx.impl"</span>)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Class cls = ClassUtils.resolveClassName(beanClsName, Thread.currentThread().getContextClassLoader());</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfacesAsSet(cls);</span><br><span class="line">           <span class="keyword">if</span> (CollectionUtils.isEmpty(interfaces)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; interfaceCls : interfaces) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ClassUtils.isAssignable(IProxyBaseService<span class="class">.<span class="keyword">class</span>, <span class="title">interfaceCls</span>)) </span>&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               checkInterfaceMethods(interfaceCls);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><a name="dyGDj"></a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在bean没有实例化好的时候，不能随便使用beanFactory.getBeansOfType这个方法，这个会坑死人的</li>
<li>在bean没有实例化时做一些校验，能减少系统资源的开销(链接创建/资源分配等)，但实现的时候需要千万小心</li>
</ul>
<br>

]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>使用松散索引优化SQL</title>
    <url>/2020/07/18/%E4%BD%BF%E7%94%A8%E6%9D%BE%E6%95%A3%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96SQL/</url>
    <content><![CDATA[<p><a name="rEULd"></a></p>
<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html</a> (松散索引的官方解释)</li>
</ul>
<p><a name="yjrHT"></a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><br>对于物联网行业来说，当业务增长之后，其对应的数据增长的速度是非常快的，因为设备每时每刻都在产生数据，这样某些表上的数据已经悄悄的上了千万级别，这时候就急需对其做一定的优化。其中最常见的就是水平拆分了。拆分之前第一步要做的就是数据统计分析，而由于数据量级摆在这儿，所以在统计的时候SQL执行超时就很常见了，这时候就需要做优化<br><br><br><br><br>假设某个表记录的设备的上报记录，而且该表由于历史原因存储的不止一种业务数据，其的结构如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`dev_history`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`dev_id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'设备id'</span>,</span><br><span class="line"><span class="string">`value`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'value'</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">smallint</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'状态'</span>,</span><br><span class="line"><span class="string">`gmt_create`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`gmt_modified`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`idx_devid`</span> (<span class="string">`dev_id`</span>,)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在希望将某个业务的数据统计出来，然后做拆分。统计分析的工作主要分两块:</p>
<ul>
<li>将每条设备有多少条记录找出来</li>
<li>对每个设备进行分析，分析其是否是你期望的业务</li>
</ul>
<p>有了上面两个数据，就可以知道知道数据增长的趋势，从而对如何水平拆分提供参考.<br><br><br></p>
<p><a name="FSoQK"></a></p>
<h3 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h3><p>对于统计每个设备的有多少数量，一开始SQL写成如下这样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dev_id, <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span> dev_history <span class="keyword">group</span> <span class="keyword">by</span> dev_id;</span><br></pre></td></tr></table></figure>

<p><br>从执行计划看，走的是索引。嗯，感觉还不错，应该会挺快的。然而由于设备的数量有几十万条，所以即使走索引也会很慢，而且在统计的时候不可能一次性将几十万的数据都捞出来，统计程序会直接进ICU的<br><img src="/2020/07/18/%E4%BD%BF%E7%94%A8%E6%9D%BE%E6%95%A3%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96SQL/1.png" alt="image.png"><br><br><br>那怎么办，只能limit了，改造之后的SQL如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dev_id <span class="keyword">as</span> devId, <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span> dev_history <span class="keyword">group</span> <span class="keyword">by</span> dev_id <span class="keyword">order</span> <span class="keyword">by</span> dev_id <span class="keyword">limit</span> <span class="number">0</span>, <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>以上SQL跑起来之后还是很容易超时:</p>
<ul>
<li>limit的offset到后面的时候会很大，虽然走的是索引但是还是会遍历很多无用的数据. 对于这种问题，一般会想到的做范围限制，但是由于每个设备无时无刻都在生产数据，所以他们之间不存在先后顺序(即id和gmtCreate都不适用)，所以无法做范围限制. </li>
<li>有个小问题是: 由于group by默认会对作用的字段做排序，所以这里就不需要做 order by了</li>
</ul>
<br>

<p><a name="IgePG"></a></p>
<h3 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h3><p>最后的解决方案是: 通过松散索引来解决。松散索引是跟紧凑索引相对的。</p>
<ul>
<li>紧凑索引，是走了索引，一般是查找范围查找或者是 全索引查找<blockquote>
<p>A Tight Index Scan may be either a full index scan or a range index scan, depending on the query conditions. When the conditions for a Loose Index Scan are not met, it still may be possible to avoid creation of temporary tables for <code>GROUP BY</code> queries</p>
</blockquote>
</li>
</ul>
<ul>
<li>所谓松散索引，是在做数据统计的时候不是遍历索引，而是会跳过相同的数据。而且一般在group by的时候会使用到。比如MySQL在group by作用的所有的字段都在索引上，那么它就会走松散索引。我们这里的例子就是 dev_id是有索引的<blockquote>
<p>The most efficient way to process <code>GROUP BY</code> is when an index is used to directly retrieve the grouping columns. With this access method, MySQL uses the property of some index types that the keys are ordered (for example, <code>BTREE</code>). This property enables use of lookup groups in an index without having to consider all keys in the index that satisfy all <code>WHERE</code> conditions. This access method considers only a fraction of the keys in an index, so it is called a Loose Index Scan. When there is no <code>WHERE</code> clause, a Loose Index Scan reads as many keys as the number of groups, which may be a much smaller number than that of all keys. If the <code>WHERE</code> clause contains range predicates (see the discussion of the <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a> join type in <a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">Section 8.8.1, “Optimizing Queries with EXPLAIN”</a>), a Loose Index Scan looks up the first key of each group that satisfies the range conditions, and again reads the smallest possible number of keys</p>
</blockquote>
</li>
</ul>
<br>
<br>
<br>所以可以对我们的SQL做一定的改造

<ul>
<li>第一步中只获取不重复的dev_id</li>
<li>第二步，再通过dev_id去获取对应的count数据。因为每个dev_id的记录数据不会很大，最多几十万，并且它有索引所以查询起来还是比较快的</li>
</ul>
<p>这样以来，就可以减轻每一步的压力，还能获取到对应的数据。对于第一步，获取不重复的dev_id的SQL如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dev_id <span class="keyword">from</span> dev_history  <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">group</span> <span class="keyword">by</span> dev_id;</span><br></pre></td></tr></table></figure>

<p><br>对应的执行计划如下, 其中 “<strong>Using index for group-by</strong>“ 表示的就是当前SQL执行时使用的是松散索引<br><img src="/2020/07/18/%E4%BD%BF%E7%94%A8%E6%9D%BE%E6%95%A3%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96SQL/2.png" alt="image.png"><br><br><br><br><br></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>SQL优化</category>
      </categories>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>《架构整洁之道》-读书笔记</title>
    <url>/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a name="4B1fS"></a></p>
<h3 id="组件聚合"><a href="#组件聚合" class="headerlink" title="组件聚合"></a>组件聚合</h3><p>组件的发展会经历:</p>
<ol>
<li>快速发展</li>
<li>沉淀</li>
<li>分离</li>
</ol>
<p><br>快速发展阶段，会讲相同/相似，更确切的说是有相关性的功能放在一块.(这个阶段也可以理解为攀亲戚，各种八竿子打不着的都可能会被强扭在一块)。<br>经历快速发展之后，会发现修改一处代码，会有很多相似的代码也需要去修改，一旦遗漏了某处肯能就会出现一个大的故障。此时会将哪些相同的东西抽取出来，形成一个基础的东西，从而增加代码复用性<br><br><br>最后当组件越来越大，发现很多功能是不能在一起的，就会做拆分。在分离/引入依赖的时候，最好做彻底点，不能因为引用了一个类就将那个依赖引进来，这样很容易会发生被依赖方一变动，依赖方必须跟着变动。<br><br><br>所以以上对应的组件构建的三个原则是:</p>
<ol>
<li>CCP: 共同闭包原则 <ol>
<li>将那些会同时修改并且是为相同目的而修改的类放到同一个组件中；将那些不会同时修改，并且不是因为相同目的而修改的类放到不同的组件中</li>
<li>这个是SRP原则在组件层面的一个阐述. SRP: 单一职责原则</li>
</ol>
</li>
<li>REP: 复用/发布等同原则<ol>
<li>一个组件不能由一堆毫无关系的类和模块组成。 而应该是由具有相同目的/功能的类和模块组成</li>
<li>组件中的类或者模块，在发布的时候大家是一起发布的，不能存在某些可以发布，某些不能发布。即: 软件复用的最小粒度等同于其发布的最小粒度</li>
</ol>
</li>
<li>CRP: 共同复用原则<ol>
<li>不要强迫一个组件依赖它们不需要的东西。是ISP(接口分离原则)在组件层面的阐述</li>
</ol>
</li>
</ol>
<br>

<p><a name="1TlOQ"></a></p>
<h3 id="组件耦合"><a href="#组件耦合" class="headerlink" title="组件耦合"></a>组件耦合</h3><p>项目的程序发展应该是向这么个架构发展: 顶层 到 底层的走向，每走一步都是向更稳定的方向走，即底层是最稳定的，也是最不容易变动的。因为它一变动依赖他的都要跟着变动，代价太大。<br><br><br>那么如果底层既想要稳定又想要有一些高阶的策略设计呢？这就可以将底层设计成抽象类，一部分是稳定的不变的，一部分是抽象方法. 这样依赖它的地方就可以做到扩展，而它自己只是做了一些高阶的设计<br><br><br></p>
<p><a name="x94Xs"></a></p>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>系统在设计的时候应该在水平进行分层，垂直也要做一定的切分。这样做了之后会让系统的各个功能之间独立，从而可以在将来拆分出来做一个单独服务出去</p>
<ul>
<li>水平分层，很常见. controller/service/manager/dao的划分就是很常见的一种方式</li>
<li>垂直划分，一般都是以业务进行划分。比如创建订单/删除订单</li>
</ul>
<p><br>关于重复: 并不是所有的代码重复都是需要被处理的。有时候代码的重复是为了以后业务方向不同而做的，只是暂时的，随着业务发展，重复的代码将会变得很不一样，这种就是表面重复。如果硬将它们写在一起，等到后面业务发展的时候就有很多if/else之类的代码了，越到后面越难切割开了<br><br><br><br><br>解耦的方式有以下几种</p>
<ul>
<li>源代码层的解耦。这种方式下，我们通过控制源码层面上不同模块之间的依赖关系，来达到一个模块的改动不会引起其他模块的改动，常用的是水平/垂直的切分</li>
<li>部署上的解耦，将部署隔离开来。比如某个业务/模块形成单独的jar，要发布它只是将其加入到应用程序中，然后重新部署，而不会影响到其他的jar</li>
<li>服务层次的解耦，就是常说的微服务。这种是数据结构的解耦，各个服务之间的通信只要知道数据接口就可以了。但微服务一般在设计之处都是以粗粒度进行规划的，可能发展到后面，一个微服务又需要再次进行拆分为多个子微服务</li>
</ul>
<p><a name="4PZ1b"></a></p>
<h3 id="策略与层次，关键业务"><a href="#策略与层次，关键业务" class="headerlink" title="策略与层次，关键业务"></a>策略与层次，关键业务</h3><p>一个软件系统，处理的是接受输入信息，经过一定的业务逻辑处理，输出结果。架构设计时，要把系统按照离I/O的远近来分层，离I/O越近的其易变性更大，而离I/O越远的则稳定性更强。所以在设计依赖关系时应该让易变性组件依赖稳定性组件，形成一个DAG(有向无环图)，最好是以插件的形式出现。<br>在代码实现的过程中，也尽量按照DAG的方向进行编写归类。<br><br><br>而一个系统中总有某些业务是可以用来赚钱或者省钱，离开它该体统就没有什么价值了，该类业务称之为关键业务，其处理的数据则是关键数据，对应的处理逻辑则为关键逻辑。一般在设计的时候，都应该将它们放在一块(这里的一块并不是说放在一个类中，毕竟如果业务复杂的话，放在一个类中会让代码非常冗长), 我们可以称之为核心域。它应该是离I/O较远的，所以它也应该是较稳定的<br><br><br></p>
<p><a name="Ek2Os"></a></p>
<h3 id="架构整洁设计"><a href="#架构整洁设计" class="headerlink" title="架构整洁设计"></a>架构整洁设计</h3><ol>
<li>框架只是实现细节的一部分，不应该影响架构的设计<blockquote>
<p>一个系统在设计之初，不应该局限于它要采用哪种框架而应该考虑它是为什么业务而生的，它的用例有哪些？并通过这些用例抽取出核心业务出来。当一个新人来的时候，不应该问系统使用的是何种框架，而应该关心有哪些用例从而快速上手</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>架构师应该在确保当前架构设计满足用例的前提下，尽可能地允许用户能自由的选择建筑材料(石料，砖头或者木材)，在软件行业就是使用哪种框架，哪种类型的存储系统(关系型数据库还是NoSQL数据还是其他的)</p>
</blockquote>
<p><br>一个系统的架构是否整洁，关键看设计开发的时候是否遵循严格的分层原则。尤其是在实现的过程中，对于跨界的处理是否不越界，是否数据流向依然是从低层次指向高层。处理的方式一般是在内层定义接口，然后让外层去实现，以达到解耦的目的<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/1.jpg" alt="CleanArchitecture.jpg"><br>用例是在关键业务的外围，它们协调指挥关键业务的数据流转从而实现业务目标；而数据库，哪种web技术，展现形态，等等都是易变的，所以它们应该离同心圆很远<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2.png" alt="image.png"><br><br><br></p>
<p><a name="E4TFf"></a></p>
<h3 id="服务-宏观与微观"><a href="#服务-宏观与微观" class="headerlink" title="服务: 宏观与微观"></a>服务: 宏观与微观</h3><p>将系统以微服务架构进行设计，在运行一段时候之后，可能会遇到横跨型变更(cross-cutting concern)问题。所谓横跨型变更问题是指，一个需求过来，所有的微服务或者大部分的微服务都需要做变更以适应需求变更。<br><br><br>如果服务之间有耦合的东西，比如它们公用了同一个数据库表，那么数据库表的字段变更了，所有涉及到的微服务都要变更。这其实各个服务之间就不是完全的解耦. 所以一般我们都是一个微服务一个数据库，做到垂直隔离<br></p>
<p><a name="CzaTe"></a></p>
<h4 id="类滴滴系统架构的解耦"><a href="#类滴滴系统架构的解耦" class="headerlink" title="类滴滴系统架构的解耦"></a>类滴滴系统架构的解耦</h4><p>对于横跨型变更，如何解决？答案是采用组件化的方式来处理，将不同业务做成不同的组件. 比如一个类似滴滴的系统<br><br><br>初始的架构<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/3.png" alt="image.png"><br><br><br>应对横跨型变更问题-单体应用的解耦，在架构内部采用组件化架构<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/4.png" alt="image.png"><br><br><br><br><br>应对横跨型变更问题-微服务的解耦，在各个微服务的内部采用组件化架构<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/5.png" alt="image.png"><br><br><br><br><br></p>
<p><a name="hmxoQ"></a></p>
<h3 id="代码组织架构"><a href="#代码组织架构" class="headerlink" title="代码组织架构"></a>代码组织架构</h3><p><a name="d9GE9"></a></p>
<h4 id="按层封装"><a href="#按层封装" class="headerlink" title="按层封装"></a>按层封装</h4><p>大部分单体应用，在初创期，都是按照controller/service/dao进行分类的. 但是随着业务发展，团队的壮大，会出现直接controller调用dao的情况(即所谓的”宽松分层架构”的出现). 并且这种架构的弊端是找一个业务的相关代码需要找很多地方。如果后期壮大到需要将单体分拆为多个微服务，更是一通好找。<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/6.png" alt="image.png"><br></p>
<p><a name="ZP0wr"></a></p>
<h4 id="按功能封装"><a href="#按功能封装" class="headerlink" title="按功能封装"></a>按功能封装</h4><p>按功能分，就是将功能相关的代码都集中到一个package中，然后里面包含了所有.这种的话，复用是个问题，毕竟对外暴露的是controller，其他诸如service/dao是对外不可见的<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/7.png" alt="image.png"><br></p>
<p><a name="mNvrO"></a></p>
<h4 id="以业务领域-实现进行分离"><a href="#以业务领域-实现进行分离" class="headerlink" title="以业务领域+实现进行分离"></a>以业务领域+实现进行分离</h4><p>采用“端口和适配器”架构，将核心域(业务领域)的东西放到一个package内，将其他具体实现放到其他package；<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/8.png" alt="image.png"><br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/9.png" alt="image.png"><br></p>
<p><a name="jwJIS"></a></p>
<h4 id="以组件形式封装"><a href="#以组件形式封装" class="headerlink" title="以组件形式封装"></a>以组件形式封装</h4><p>最后一种是以组件的形式对外暴露. controller是一个package，其他的都以component的形式对外暴露，类似于facade模式<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/10.png" alt="image.png"><br><br><br></p>
<p><a name="sKMN8"></a></p>
<h4 id="各个组织形式的对外暴露的形态"><a href="#各个组织形式的对外暴露的形态" class="headerlink" title="各个组织形式的对外暴露的形态"></a>各个组织形式的对外暴露的形态</h4><p><br>以下是各个组织形式下，对外暴露的内容. 其中虚化的是内部对外不可见的类，即非public的<br><img src="/2020/10/18/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/11.png" alt="image.png"><br><br><br><br><br><br><br></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《领域驱动设计精粹》-读书笔记</title>
    <url>/2020/05/30/%E3%80%8A%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B2%BE%E7%B2%B9%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a name="xJ6L8"></a></p>
<h3 id="chapter-1-设计"><a href="#chapter-1-设计" class="headerlink" title="chapter 1: 设计"></a>chapter 1: 设计</h3><ul>
<li>过度设计，毫无设计，都是不可取的；最好的是适度设计，演进式地对设计进行升级改造而不是一蹴而就的</li>
<li>闭门造车想出来的产品功能，也是不可取的</li>
<li>不是有效设计就是糟糕的设计，不存在什么“毫无设计”一说</li>
<li>领域设计中有两个概念<ul>
<li>战略设计，是高层次的设计，一般是划分上下文</li>
<li>战术设计，是上下文中实现的设计</li>
</ul>
</li>
</ul>
<br>
<br>

<p><a name="7o3tN"></a></p>
<h3 id="chapter-2-限界上下文的定义"><a href="#chapter-2-限界上下文的定义" class="headerlink" title="chapter 2: 限界上下文的定义"></a>chapter 2: 限界上下文的定义</h3><ol>
<li>MVP(Minimum Viable Product)产品原则: 功能最小的产品原则，提倡在产品需求研发过程中聚焦于最小化可行产品上，不断获取用户的反馈并持续迭代。韩国的一些电视剧的拍摄模式就采用类似这样的方式，先拍几集播放出来之后看市场反馈，如果ok则开始写接下来的剧本并拍摄，否则可能就面临砍掉的风险</li>
</ol>
<ol start="2">
<li>同时在需求评审过程中，不要过早地提及技术实现细节，毕竟技术是为产品服务的，如果产品功能合理，那么就需要花时间去攻克技术难点。若时间不允许，在评审中可以考虑让产品功能以另外一种方式实现。所以要先了解需求之后再进行技术的评估，不要让技术引导产品的走向(虽然有时候这种方式能带来很好的效果)</li>
</ol>
<ol start="3">
<li>限界上下文，这个其实就是领域的概念了. 不同的限界上下文中<ul>
<li>他们的仓库一般都是不一样的。即代码各管个的</li>
<li>他们的规范也可能是不一样的，每个限界上下文的规范可能是自成一派.</li>
<li>开发的时候，一般是一个团队负责一个限界上下文，如果其他团队希望来共建，那么也是可以的，但前提是需要遵守该限界上下文中的规范，提交的代码由该限界上下文的负责团队进行review审批</li>
</ul>
</li>
</ol>
<ol start="4">
<li>限界上下文的定义过程中<ul>
<li>要遵循只有最核心的概念才能归属于该限界上下文，不是核心的不要进来. 否则该限界上下文将会变得非常庞大，最终成为一个大泥球</li>
<li>一个概念要加进来的时候，要去质疑它是否是核心概念？够不够资格？</li>
<li>限界上下文的定义是一个渐进过程，研发人员/测试人员/业务专家(通常是产品)等角色都可能会发现问题，当发现问题的时候最好大家一起当面沟通，提高效率. 毕竟沟通过程中可能会有其他问题迸出来</li>
<li>领域模型的定义，不要跟相关的实现技术糅合在一起，因为领域模型是跟技术无关的，用哪种技术实现都是ok的</li>
</ul>
</li>
</ol>
<br>

<ol start="5">
<li>在没有很好划分限界上下文的时候，系统可能就是一个大泥球(Ball of Mud), 之所以这么说是因为系统是有多个没有明确边界并且纠缠在一期的模型组成，类似麻花拧在一块，内部的连线错综复杂。没人敢乱动，也没人想去动</li>
</ol>
<br>

<ol start="6">
<li>在进行领域划分的时候，可能会遇到一个术语在不同的领域内表达的含义不一样，这时候就要考虑在每一个领域内都定义一个该术语以清晰的表达业务含义。但需要注意的是，在各自的领域内命名需要遵循正交性，比如在很多地方都有一个叫西湖的，比如<ul>
<li>杭州西湖</li>
<li>惠州西湖</li>
</ul>
</li>
</ol>
<p>但是在在自己领域内(比如在杭州)就没必要说将该湖命名为杭州西湖，直接将其命名为西湖即可。因为它和它所在的领域正交起来就是: 杭州西湖<br><br><br></p>
<ol start="7">
<li>只有业务复杂复杂到一定程度的时候才需要考虑使用DDD模式进行开发，如果业务很简单，只有CRUD并且不涉及到其他系统，那么就没有必要使用DDD。否则会增加系统的复杂性</li>
</ol>
<br>

<ol start="8">
<li>在软件的整个生命周期中，都需要创新. 但是我们会有这么一个误区: 需求迭代过程中我们会进行创新，毕竟迭代的时候会有新的功能点出来，但是等到软件进入维护阶段则不会进行创新了，但这是错误的，因为维护阶段不代表软件已经死了，只是该阶段的创新相比其他阶段会少一些，但不能说停止了</li>
</ol>
<br>

<ol start="9">
<li>DDD的限界上下文的划分跟微服务的粒度的大小的定义很相似。 其实DDD中的一个限界上下文内可能包含多个微服务。微服务粒度的划分，没有一个标准答案，因为它是一个设计决策，微服务的粒度其实是团队做出的决策，在决定之前团队对它的粒度可以进行质疑探讨，毕竟这是一个架构设计。可以从以下几点去考虑自己的微服务粒度大小<ul>
<li>现有架构间的依赖关系</li>
<li>业务的扩展性</li>
<li>团队人员的能力</li>
<li>最后是在实现期间可能会遇到的风险和挑战</li>
</ul>
</li>
</ol>
<br>
<br>

<p><a name="7Vt1w"></a></p>
<h3 id="chapter-3-子域"><a href="#chapter-3-子域" class="headerlink" title="chapter 3: 子域"></a>chapter 3: 子域</h3><p><br>子域是一个小的功能领域，在java中就是一个package的划分。 在使用DDD时，理想情况下是一个限界上下文对应一个子域(1:1的关系)，因为这样可以让限界上下文的目标清晰并且专注于核心战略。如果必须在同一个界限上下文(核心域)中创建第二个模型，那么应该使用一个完全独立的模块将该模型从核心域中分离出来(在java中就是新建一个package)。<br><br><br>子域分为3中类型</p>
<ul>
<li>核心域，这种类型的域是唯一的并且定义明确的领域模型，是团队甚至公司的区分其他竞争对手的核心所在，需要花大力气大资源去攻克的领域，是公司/团队的战略所在</li>
<li>支撑子域，这类领域通常是定制的，一般可复用性较差，可以花较少的精力去做</li>
<li>通用子域，这一类的领域通常是各个领域公共的，构建的时候主要需要考虑其稳定性和兼容性，不要影响到其他的域，毕竟是公用的</li>
</ul>
<p><br>他们之间的重要性: 核心域 &gt; 支撑子域 &gt; 通用子域。对于一个大泥球系统，可以尝试对其进行子域划分，这样可以把问题划分清除，方便后期进行改造迁移<br><br><br></p>
<p><a name="UzyMc"></a></p>
<h3 id="chapter-4-界限上下文之间的关系与交流"><a href="#chapter-4-界限上下文之间的关系与交流" class="headerlink" title="chapter 4: 界限上下文之间的关系与交流"></a>chapter 4: 界限上下文之间的关系与交流</h3><p><br>界限上下文之间的关系，其实跟微服务之间的关系大同小异，它们之间的关系有:</p>
<ul>
<li>合作关系。这种关系各个团队有共同的目标，大家步调一致。但是要注意的是合作要有一个期限，不能永久合作，因为只有设置了期限才能保持一个良性的合作，否则很可能到后面两个领域模型不区分彼此糅合在一起形成”大泥球”</li>
<li>共享内核。该关系意味着各个领域模型之间有交集，大家需要共建该交集。可以采用内部开源的方式进行共建(大家遵循一定的规范进行代码维护集成)</li>
<li>客户-供应商关系。该关系就是有一方需要依赖另一方提供的服务才能进一步业务展开，这时候<ul>
<li>作为服务提供方的服务需要注意在升级API的时候要做兼容</li>
<li>使用方(客户方)，则需要遵循提供方的游戏规则进行玩耍，会有点被动；但好处是可以借助大树好乘凉，比如借助阿里云平台/amazon平台，快速搭建服务开展业务，缺点是很多产品只能使用所选云平台的服务</li>
</ul>
</li>
<li>防腐层。每个界限上下文使用该层来隔离依赖领域的升级对自己领域的侵入，防腐层一般都会将依赖领域的业务术语翻译成自己领域内的业务语言，相同的也会将自己的业务语言转化为依赖领域的业务语言，充当一个翻译官的角色。这一层做好之后，可以在这一层上面做一层熔断降级，减少被依赖服务弄死的情况</li>
<li>API模式<ul>
<li>改种模式跟 客户-供应商 关系类似</li>
<li>服务与服务之间通过 API进行交流</li>
<li>API的提供方需要提供完备的 API文档以让使用方快速入手，很适合没有时间构建自己的防腐层的领域</li>
</ul>
</li>
<li>各行其道。这种模式是DDD最希望看到的，就是各个领域各管各的，互不相干</li>
</ul>
<br>

<p><a name="noN1M"></a></p>
<h4 id="领域之间的交流方式"><a href="#领域之间的交流方式" class="headerlink" title="领域之间的交流方式"></a>领域之间的交流方式</h4><p>跟微服务之间的沟通交流方式是一样的，分以下几种</p>
<ul>
<li>RPC，自己在TCP之上做了一层，用于各个服务的通信. 序列化基本都会自己做，适合数据块小的场景</li>
<li>RESTful<ul>
<li>REST就是把服务当作资源来使用了</li>
<li>一般是HTTP协议进行，可以适配数据量大的场景，但是会由于HTTP封包/拆包，header过多等问题导致资源利用率不高的问题</li>
<li>需要注意的是REST API的定义需要根据 调用方的需求来，而不是提供方想怎么就怎么样。因为提供方自己臆想出来的API可能根本满足不了调用方的需求</li>
</ul>
</li>
<li>消息通知<ul>
<li>一般都是至少触达一次</li>
<li>需要考虑<ul>
<li>重复消费时，保证业务的幂等</li>
<li>对于消息延迟达到，需要在系统设计之处就考虑进去，做好相应的处理，保证系统的健壮性</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<br>以上几种方式，都需要注意一点，就是避免连坐效应的发生:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A ---&gt; B ---&gt; C</span><br></pre></td></tr></table></figure>
由于B调用C慢导致A调用B被连坐，这里可以通过超时机制/异步机制等方式进行解决<br>
<br>
<br>在DDD模型中，通过 消息通知 进行上下文界限的沟通交流，一般是

<ul>
<li>通过领域模型中的 aggregate发布的Domain Event</li>
<li>感兴趣的领域会收到 Domain Event，进行自己的业务处理</li>
<li>由于可能会有多个consumer，所以发出的 Domain Event中的数据可以有两种<ul>
<li>肥胖型的Domain Event: 里面包含的数据内容涵盖大部分的consumer所需的数据<ul>
<li>这样会造成Domain Event中的数据很多</li>
<li>数据多容易造成数据安全问题</li>
<li>同时对传输带宽会形成压力</li>
<li>对每个consumer来说也会有压力，因为可能当前consumer只想要Domain Event中的几个字段，其他的字段都是无用的。解析起来很费劲</li>
</ul>
</li>
<li>瘦弱型的: 只提供极精简的数据，各个consumer如果需要其他而外的数据，可以通过 事件源领域的API进行查看<ul>
<li>当然这样也会造成多次的领域间的通信，因为当consumer需要额外的数据时，就必须通过调用API的方式获取数据</li>
<li>但对于大部分consumer来说，Domain Event中的基本数据是能满足它们的业务需求的</li>
</ul>
</li>
<li>具体选择 瘦子还是胖子，要根据自己的业务来定</li>
</ul>
</li>
</ul>
<br>
<br>

<p><a name="t7UGf"></a></p>
<h3 id="chapter-5-聚合"><a href="#chapter-5-聚合" class="headerlink" title="chapter 5: 聚合"></a>chapter 5: 聚合</h3><p>聚合简单的理解，就是根据业务将一些相关的逻辑聚在一起，并且它们之间的状态会保持一致，所以一般来说一个聚合就是一个事务。聚合有几个重要的元素</p>
<ul>
<li>实体，可以认为是一个数据的表示，但跟面向对象中的实体稍微会不一样，因为DDD中的实体其实是充血对象，里面除了属性之外，还会有行为</li>
<li>值对象，对，它们就是值，在生成之后就不变的东西，比如常量，或者是一个实体的id(生成之后是不会变的)</li>
</ul>
<p><br>每个聚合有一个根实体，该实体控制着聚合内的其他元素，一般聚合的名称就是按照根实体的名称来命名<br><br><br><br><br>聚合经验法则</p>
<ul>
<li>在聚合边界内保护业务规则保持不变，即保持事务一致<ul>
<li>考虑的时候，将状态有关联性的东西放在一起，形成一个聚合</li>
<li>提交的时候一起提交，保证各自的状态保持正确，不会错乱</li>
<li>一般有个原则就是，需要即时响应发生的，放在一个聚合里。可以延时发生的，可以放到不同的聚合，通过领域事件保持最终一致性</li>
</ul>
</li>
<li>聚合不要设计的太大，要尽量小，否则会变得很臃肿<ul>
<li>不要将两个实体放在一个聚合内，否则会将聚合撑大</li>
</ul>
</li>
<li>不同聚合之间通信通过标识来引用</li>
<li>不同聚合之间，通过最终一致性来保持</li>
</ul>
<br>
<br>关于贫血模型: 对象中，只有Getter/Setter，没有其他的业务行为。一般的贫血模型，都是在外面进行业务设置，或者在工具类中进行业务处理. 这样的好处是: 保持对象的干净；坏处就是业务会散落在各处，会不好管理<br>
<br>充血模型，在DDD中会将业务都封装在对象中，这样业务管理比较方便。但对熟悉面向对象的朋友可能会不太好理解<br>
<br>

<p><a name="kkz3r"></a></p>
<h3 id="chapter-6-领域事件"><a href="#chapter-6-领域事件" class="headerlink" title="chapter 6: 领域事件"></a>chapter 6: 领域事件</h3><p><br>领域事件，是不同聚合沟通的桥梁。一般领域事件的触发有两种情况</p>
<ul>
<li>由命令触发，所谓命令是由用户操作了某个动作而发出的指令。由命令触发而来的领域事件，在处理的时候可以根据业务需要拒绝处理</li>
<li>由于时间到了而触发，即时间领域事件。该类领域事件不能拒绝，必须无条件地进行处理</li>
</ul>
<br>
<br>领域事件的其他

<ul>
<li>一般领域事件的内容中都有一个sourceId，由于记录该事件的发起方是谁. 比如我们发送MQ消息的时候，也会这么干，这样有助于在处理的时候进行适当的分派；</li>
<li>领域事件的命名，一般通过命令来。并且是过去式. 比如命令叫: bookHotel, 那么事件的名称就是: hotelBooked</li>
<li>所谓事件溯源，就是将发生的事情都记录起来，方便后面排查只用。平时使用的记录表就能起到这种作用，这个也是要根据实际情况操作的，并不是所有的聚合都需要事件溯源的</li>
</ul>
<br>

<p><a name="3cd7Q"></a></p>
<h3 id="chapter-7-工具"><a href="#chapter-7-工具" class="headerlink" title="chapter 7: 工具"></a>chapter 7: 工具</h3><p>事件风暴，就是快速的聚焦地分析问题-&gt;发现问题-&gt; 找到方案-&gt; 进而形成共识，主要步骤包括</p>
<ul>
<li>将大家聚在一起(开发+测试+需求方)，快速对需求过一遍，然后找到核心的领域事件</li>
<li>针对找到的领域事件，定义触发这些领域事件的命令</li>
<li>将领域事件+命令，通过实体/聚合关联起来</li>
<li>然后将聚合的流转方向定义清楚，形成一个业务流</li>
<li>最后如果有需要，可以在业务流的基础上，创建一些视图，从而可以提供更宏观层面的东西.这一步个人理解是对业务的抽象，从而更能抓住业务核心，并且可以用它来评估是否符合公司战略</li>
</ul>
<br>
<br>

<p><a name="nlhgQ"></a></p>
<h4 id="敏捷开发相关"><a href="#敏捷开发相关" class="headerlink" title="敏捷开发相关"></a>敏捷开发相关</h4><ul>
<li>No Estimates(拒绝估算): 不是否定敏捷开发的开始阶段的估算所产生的价值，而是探索在持续改进的过程中是否有一些手段可以协助或者改善估算活动，从而更加聚焦于交付价值。实践者一般会在估算阶段减少可以用的估算值的数量，比如只提供 0.5/1/3的牌，这样每个估算的得分都会很低，然后再推动团队将每个 user story进行拆解，如果可以拆解的够细，那么当task足够小交付足够快时，就可以不用对其做估算了。这样做的目的是希望更加聚焦于价值交付，而非将时间精力浪费在估算环节</li>
<li>敏捷的核心是知识获取(Knowledge Acquisition)。 通过站会，通过快速迭代，通过回顾会议等形式，快速获取到团队遇到的问题，客户的反馈等知识，从而做调整进行下一个优化迭代</li>
</ul>
<br>

<p><a name="fp5Pf"></a></p>
<h4 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h4><p>一种项目管理的方式，主要的思路是: 找到问题 –&gt; 然后找到应对之策。一般会通过划分四个象限来明确各个领域的现状</p>
<ul>
<li>S: Strength，优势是什么</li>
<li>W: Weakness，当前团队的弱点是什么. 这个不能隐藏的，否则将不自量力</li>
<li>O: Opportunity， 当前的机遇是什么，这是要将力量集中起来去抓住它攻破的东西</li>
<li>T: Threat, 威胁是什么，或者说障碍是什么</li>
</ul>
<p><br>通过分析S+W，可以对团队有一个清晰的认识。通过O+T可以知道面对的是什么，对处境及整体环境有一个较好的认知</p>
]]></content>
      <categories>
        <category>设计</category>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>maven知识整理+插件编写</title>
    <url>/2020/06/13/maven%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86+%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p><a name="9xWL1"></a></p>
<h3 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h3><ul>
<li><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a> (仲裁机制+scope等知识)</li>
<li><a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a> (lifeCycle+phase+goal)</li>
<li><a href="https://maven.apache.org/guides/plugin/guide-java-plugin-development.html" target="_blank" rel="noopener">https://maven.apache.org/guides/plugin/guide-java-plugin-development.html</a> （插件编写）</li>
<li><a href="https://maven.apache.org/guides/mini/guide-configuring-plugins.html#Using_the_executions_Tag" target="_blank" rel="noopener">https://maven.apache.org/guides/mini/guide-configuring-plugins.html#Using_the_executions_Tag</a> (插件参数的配置)</li>
</ul>
<br>
<br>我们都知道，maven可以帮助我们管理依赖，否则我们就需要采用古老的方式，单独从其他地方找到对应的jar，然后放到classpath中，这样很麻烦也很容易出现兼容问题.<br>

<p><a name="AkmXp"></a></p>
<h3 id="maven的一些知识整理"><a href="#maven的一些知识整理" class="headerlink" title="maven的一些知识整理"></a>maven的一些知识整理</h3><p><a name="l0Npl"></a></p>
<h4 id="1-maven的仲裁机制"><a href="#1-maven的仲裁机制" class="headerlink" title="1. maven的仲裁机制"></a>1. maven的仲裁机制</h4><p>所谓仲裁，就是出现冲突时会怎么抉择。maven会将项目的依赖信息，做成一棵树的形状，如果有两个一样的jar，但他们的版本不一样</p>
<ul>
<li>离树根越近的那个会被选中;</li>
<li>如果他们两个离树根的距离相等，那么就看谁是第一个被发现(依靠他们在pom中的顺序)</li>
</ul>
<p>比如A项目中有两个D的jar(他们分别是被不同的jar带进来的)，但是版本不一样, 路径如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A-&gt;B-&gt;D1.0</span><br><span class="line">A-&gt;C-&gt;E-&gt;D2.0</span><br></pre></td></tr></table></figure>
<p>那么D1.0会被选中</p>
<p><a name="zs5en"></a></p>
<h4 id="2-exclude-optional的区别"><a href="#2-exclude-optional的区别" class="headerlink" title="2.  exclude+optional的区别"></a>2.  exclude+optional的区别</h4><p>在依赖某个dependency的时候，我们可能不想要某个dependency，那么我们可以显式的通过exclude将其剔除掉，比如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>其实还有一种方式，就是optional方式，optional的意思相当于”exclude by default”, 即默认被排除掉. 比如我们在开发项目的时候，会觉得我们依赖的某个jar并不是 依赖我们所必须的，这时候就可以将其标记位optional。假设</p>
<ul>
<li>A项目依赖了<code>org.yaml:snakeyaml:1.20</code>但又不希望将它传递给依赖自己的B，那么可以在pom中作以下的dependency声明</li>
<li>那么B引用A的时候， <code>org.yaml:snakeyaml:1.20</code> 是不会加到B中来的。如果需要加进来，B自己可以显式地在自己的pom中进行定义<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<br>
<a name="HYXQc"></a>

</li>
</ul>
<h4 id="3-一个dependency的表示"><a href="#3-一个dependency的表示" class="headerlink" title="3. 一个dependency的表示"></a>3. 一个dependency的表示</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-c<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>stage<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>group-a<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifact-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- This is not a jar dependency, so we must specify type. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般的我们引入一个dependency的时候，我们只要定义其GAV(groupId, artifactId, version)即可。其实一个dependency完整的表示应该包含: GAV+type+classifier</p>
<ul>
<li>type: 表示当前是什么类型. 因为默认type=jar，所以很多时候我们不定义. 但是如果对应的dependency不是jar则需要显式声明</li>
<li>classifier: 表示当前是那种用途的，该值默认为null。比如同一个依赖(即GAV+type一样)，但是需要适应于不同的业务场景，比如一个是给客户A用的，一个是给客户B用的，那么就可以使用classifier来区分了。比如json-lib可能需要同时提供给jdk13和jdk15</li>
</ul>
<p><img src="/2020/06/13/maven%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86+%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/m-1.png" alt="image.png"><br></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.json-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk15<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><a name="zuglD"></a></p>
<h4 id="4-dependency的scope及其传递性"><a href="#4-dependency的scope及其传递性" class="headerlink" title="4. dependency的scope及其传递性"></a>4. dependency的scope及其传递性</h4><p>dependency的scope表示其作用范围，同时也确定了其传递性，有6个scope<br></p>
<table>
<thead>
<tr>
<th>scope</th>
<th>特性</th>
<th>是否会传递给依赖项</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>默认的scope</td>
<td>是</td>
</tr>
<tr>
<td>provided</td>
<td>跟compile类似. 不同之处在于:它期望在运行时JDK或者Container会提供该dependency. <br></td>
<td>否</td>
</tr>
<tr>
<td>runtime</td>
<td>在compile阶段不是必须的，是给运行时准备的</td>
<td>否</td>
</tr>
<tr>
<td>test</td>
<td>测试时使用的</td>
<td>否</td>
</tr>
<tr>
<td>system</td>
<td>跟provided类似，但是它不会区从仓库中查找对应的dependency，而是通过指定的路径区找</td>
<td>否</td>
</tr>
<tr>
<td>import</td>
<td>将另一个pom引入进来</td>
<td>是</td>
</tr>
</tbody></table>
<br>
<a name="tvvmD"></a>

<h3 id="插件相关"><a href="#插件相关" class="headerlink" title="插件相关"></a>插件相关</h3><p><a name="ZjN36"></a></p>
<h4 id="1-生命周期简单介绍"><a href="#1-生命周期简单介绍" class="headerlink" title="1. 生命周期简单介绍"></a>1. 生命周期简单介绍</h4><p><br>maven是基于build lifecycle的概念设计出来的，有三个生命周期:</p>
<ul>
<li>clean, 清理上次build的数据</li>
<li>default，负责编译打包部署</li>
<li>site，负责文档的生成</li>
</ul>
<p>其中default+clean是我们平时接触比较多的。而每个生命周期都是由多个phase组合而成的，一个phase对应一个plugin，它可能会包含多个goal. 其中goal就是一个具体的执行任务了，大致结构如下<br><img src="/2020/06/13/maven%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86+%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/lifecycle-structure.jpg" alt="生命周期.jpg"><br><br><br>其中一个phase由0个或者多个goal组成，如果该phase中没有一个goal，那么它不会执行；但如果它有多个goal，那么没有特别指定执行那个goal的情况下，它下面的所有goal都会执行。有一点需要注意的是，执行一个phase时，在它之前的所有phase都会被先执行。phase可以直接被执行，就像我们平时的 mvn clean install 其实都是直接执行phase的，只是里面的goal会被全部执行而已</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean myPhase:myGoal package</span><br></pre></td></tr></table></figure>
<p>考虑以上命令，其中clean和package是一个phase，而myPhase:myGoal是一个goal。那么这条命令会如下执行</p>
<ul>
<li>执行clean phase之前的所有phase</li>
<li>执行clean phase</li>
<li>执行 myPhase:myGoal</li>
<li>执行package之前的所有phase</li>
<li>执行package phase</li>
</ul>
<br>
<br>default build lifecycle 会包含以下phase

<ul>
<li>validate - 检查项目的正确性，比如是否有东西缺失</li>
<li>compile - 编译项目的源代码</li>
<li>test - 对编译好的代码进行测试. 可以通过 <code>-Dmaven.test.skip=true</code> 参数跳过该阶段</li>
<li>package - 对编译好的代码进行打包，通过该phase可以生成jar，所以平时我们会执行<code>mvn clean package</code> 进行打包动作</li>
<li>verify - 对测试结果进行验证，以确保达到了预期的标准</li>
<li>install -将打好的包安装到本地仓库，以方便本地的其他项目可以使用</li>
<li>deploy - 将打好的包上传到远程仓库，方便其他项目可以下载使用.</li>
</ul>
<br>

<p><a name="mIuQO"></a></p>
<h4 id="2-插件编写"><a href="#2-插件编写" class="headerlink" title="2. 插件编写"></a>2. 插件编写</h4><p>其实插件的编写就是一个写Mojo的过程. 在写好之后，如果要单独执行对应的goal需要执行如下命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn &#123;groupId&#125;:&#123;artifactId&#125;:&#123;version&#125;:&#123;goalName&#125;</span><br></pre></td></tr></table></figure>
<p>这个命令太长了，我们可以通过配置做做一些精简</p>
<ol>
<li><p>在pom中通过引入maven-plugin-plugin插件增加goalPrefix</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goalPrefix</span>&gt;</span>duplicate<span class="tag">&lt;/<span class="name">goalPrefix</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时在maven的settings.xm文件中配置如下信息. settings.xml文件的位置:</p>
<ol>
<li>自己的: <code>${user.home}/.m2/settings.xml</code></li>
<li>全局的(大家都可以看到的): <code>${maven.home}/conf/settings.xml</code></li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><a name="xjKBE"></a></p>
<h5 id="一个插件的具体的例子"><a href="#一个插件的具体的例子" class="headerlink" title="一个插件的具体的例子"></a>一个插件的具体的例子</h5><ol>
<li>pom.xml文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>duplicate-check<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>maven-plugin<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">java.encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugin-tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>backport-util-concurrent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>backport-util-concurrent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.shared<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-tree<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;java.encoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-plugin-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goalPrefix</span>&gt;</span>duplicate<span class="tag">&lt;/<span class="name">goalPrefix</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>initialize<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>properties<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>DuplicateClassCheckMojo.java 文件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.artifact.Artifact;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.execution.MavenSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugin.AbstractMojo;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugin.MojoExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugin.MojoFailureException;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.Component;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.LifecyclePhase;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.Mojo;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.Parameter;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.plugins.annotations.ResolutionScope;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.project.DefaultProjectBuildingRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.project.MavenProject;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.project.ProjectBuildingRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;</span><br><span class="line"><span class="keyword">import</span> org.apache.maven.shared.dependency.graph.DependencyNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requiresDependencyResolution的含义: 依赖包之间的关系是否需要已经存在? 如果有的依赖包不存在或者下载不下来 需不需要报错？ 这个默认是runtime, 即只会检验scope=compile+runtime的依赖</span></span><br><span class="line"><span class="meta">@Mojo</span>(name = <span class="string">"class-check"</span>, defaultPhase = LifecyclePhase.VALIDATE, requiresDependencyResolution = ResolutionScope.TEST, requiresDependencyCollection = ResolutionScope.TEST)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuplicateClassCheckMojo</span> <span class="keyword">extends</span> <span class="title">AbstractMojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameter</span>(defaultValue = <span class="string">"$&#123;project&#125;"</span>, readonly = <span class="keyword">true</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> MavenProject project;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameter</span>(defaultValue = <span class="string">"$&#123;session&#125;"</span>, readonly = <span class="keyword">true</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> MavenSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span>(hint = <span class="string">"default"</span>)</span><br><span class="line">    <span class="keyword">private</span> DependencyGraphBuilder dependencyGraphBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当有duplicate的时候，是否需要失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span>(defaultValue = <span class="string">"true"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> failOnDuplicate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要检查的groupIds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span></span><br><span class="line">    <span class="keyword">private</span> String[] excludeGroupIds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要检查的 artifactIds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span></span><br><span class="line">    <span class="keyword">private</span> String[] excludeArtifactIds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要检查的 类名字(是类的全名, 比如: com.demo.DuplicateClassFoundMojo)的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Parameter</span></span><br><span class="line">    <span class="keyword">private</span> String[] excludeClassPrefixes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DependencyNode dependencyNode = getDependencyNode();</span><br><span class="line">        <span class="keyword">if</span> (dependencyNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            getLog().info(DuplicateClassConstants.LOG_TAG + <span class="string">"dependencyNode is null"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Artifact&gt; totalArtifactIds = getArtifacts(dependencyNode);</span><br><span class="line">        resolveDependencies(totalArtifactIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DependencyNode <span class="title">getDependencyNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProjectBuildingRequest buildingRequest = <span class="keyword">new</span> DefaultProjectBuildingRequest(session.getProjectBuildingRequest());</span><br><span class="line">        buildingRequest.setProject(project);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dependencyGraphBuilder.buildDependencyGraph(buildingRequest, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DependencyGraphBuilderException e) &#123;</span><br><span class="line">            getLog().info(DuplicateClassConstants.LOG_TAG + <span class="string">"get dependency tree info failed: "</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;Artifact&gt; <span class="title">getArtifacts</span><span class="params">(DependencyNode dependencyNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Artifact artifact = dependencyNode.getArtifact();</span><br><span class="line">        <span class="keyword">if</span> (!isAllowedArtifact(artifact)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;DependencyNode&gt; children = dependencyNode.getChildren();</span><br><span class="line">        Set&lt;Artifact&gt; totalArtifacts = Sets.newHashSetWithExpectedSize(children != <span class="keyword">null</span> ? children.size() + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        totalArtifacts.add(artifact);</span><br><span class="line">        <span class="keyword">if</span> (children != <span class="keyword">null</span> &amp;&amp; !children.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DependencyNode child : children) &#123;</span><br><span class="line">                Artifact childArtifact = child.getArtifact();</span><br><span class="line">                <span class="keyword">if</span> (!isAllowedArtifact(childArtifact)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                totalArtifacts.add(childArtifact);</span><br><span class="line">                List&lt;DependencyNode&gt; myChildren = child.getChildren();</span><br><span class="line">                <span class="keyword">if</span> (isCollectionEmpty(myChildren)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (DependencyNode myChild : myChildren) &#123;</span><br><span class="line">                    Set&lt;Artifact&gt; artifactFromChild = getArtifacts(myChild);</span><br><span class="line">                    <span class="keyword">if</span> (!isCollectionEmpty(artifactFromChild)) &#123;</span><br><span class="line">                        totalArtifacts.addAll(artifactFromChild);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalArtifacts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAllowedArtifact</span><span class="params">(Artifact artifact)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> artifact != <span class="keyword">null</span> &amp;&amp; !Artifact.SCOPE_TEST.equals(artifact.getScope());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCollectionEmpty</span><span class="params">(Collection myChildren)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myChildren == <span class="keyword">null</span> || myChildren.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resolveDependencies</span><span class="params">(Set&lt;Artifact&gt; totalArtifactIds)</span> <span class="keyword">throws</span> MojoFailureException, MojoExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (totalArtifactIds == <span class="keyword">null</span> || totalArtifactIds.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; skipCheckGroupIds = excludeGroupIds == <span class="keyword">null</span> ? Collections.emptySet() : Sets.newHashSet(excludeGroupIds);</span><br><span class="line">        Set&lt;String&gt; skipArtifactIds = excludeArtifactIds == <span class="keyword">null</span> ? Collections.emptySet() : Sets.newHashSet(excludeArtifactIds);</span><br><span class="line">        Set&lt;String&gt; skipClassPrefixes = excludeClassPrefixes == <span class="keyword">null</span> ? Collections.emptySet() : Sets.newHashSet(excludeClassPrefixes);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; classArtifactIdMap = Maps.newHashMapWithExpectedSize(<span class="number">1024</span>);</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; classArtifactIdListMap = Maps.newHashMapWithExpectedSize(<span class="number">1024</span>);</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; classDistinctArtifactIdCountMap = Maps.newHashMapWithExpectedSize(<span class="number">1024</span>);</span><br><span class="line">        totalArtifactIds.forEach(item -&gt; &#123;</span><br><span class="line">            File file = item.getFile();</span><br><span class="line">            <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String groupId = item.getGroupId();</span><br><span class="line">            <span class="keyword">final</span> String artifactId = item.getArtifactId();</span><br><span class="line">            <span class="keyword">if</span> (skipArtifactIds.contains(artifactId) || skipCheckGroupIds.contains(groupId)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String gaItem = groupId + DuplicateClassConstants.COMMA_STR + artifactId;</span><br><span class="line">            String gavItem = gaItem + DuplicateClassConstants.COMMA_STR + item.getVersion();</span><br><span class="line">            List&lt;String&gt; classes = FileRetriever.getClassesFromPath(file);</span><br><span class="line">            <span class="keyword">for</span> (String foundClassItem : classes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isClassShouldSkip(foundClassItem, skipClassPrefixes)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (classArtifactIdMap.containsKey(foundClassItem)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> String lastGavItem = classArtifactIdMap.get(foundClassItem);</span><br><span class="line">                    <span class="keyword">if</span> (lastGavItem.equals(gavItem)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Set&lt;String&gt; existingGavItems = classArtifactIdListMap.getOrDefault(foundClassItem, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                    <span class="keyword">if</span> (existingGavItems.contains(gavItem)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    existingGavItems.add(lastGavItem);</span><br><span class="line">                    existingGavItems.add(gavItem);</span><br><span class="line">                    classArtifactIdListMap.put(foundClassItem, existingGavItems);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 同样的artifact但是version不一样的, 比如都是 fastjson, 可能有1.0 和 2.0</span></span><br><span class="line">                    String lastGaItem = getGaInfo(lastGavItem);</span><br><span class="line">                    Set&lt;String&gt; existingGaSet = classDistinctArtifactIdCountMap.getOrDefault(foundClassItem, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                    existingGaSet.add(gaItem);</span><br><span class="line">                    existingGaSet.add(lastGaItem);</span><br><span class="line">                    classDistinctArtifactIdCountMap.put(foundClassItem, existingGaSet);</span><br><span class="line">                &#125;</span><br><span class="line">                classArtifactIdMap.put(foundClassItem, gavItem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log(classArtifactIdListMap, classDistinctArtifactIdCountMap);</span><br><span class="line">        <span class="keyword">if</span> (!classArtifactIdListMap.isEmpty() &amp;&amp; failOnDuplicate) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MojoFailureException(DuplicateClassConstants.LOG_TAG + <span class="string">"there are classes existing in multiple artifact, please check!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isClassShouldSkip</span><span class="params">(String foundClassItem, Set&lt;String&gt; skipClassPrefixes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCollectionEmpty(skipClassPrefixes)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> skipClassPrefixes.stream().filter(StringUtils::isNotBlank).anyMatch(foundClassItem::startsWith);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; classArtifactIdListMap, Map&lt;String, Set&lt;String&gt;&gt; classDistinctArtifactIdCountMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classArtifactIdListMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getLog().warn(DuplicateClassConstants.LOG_TAG + <span class="string">"duplicate class size: "</span> + classArtifactIdListMap.keySet().size());</span><br><span class="line">        classArtifactIdListMap.forEach((classItem, artifactIds) -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; distinctGaItems = classDistinctArtifactIdCountMap.get(classItem);</span><br><span class="line">            <span class="keyword">if</span> (distinctGaItems.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                Consumer&lt;String&gt; printFun = failOnDuplicate ? getLog()::error : getLog()::warn;</span><br><span class="line">                printDuplicateClassInfo(printFun, classItem, artifactIds);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDuplicateClassInfo(getLog()::warn, classItem, artifactIds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getGaInfo</span><span class="params">(String lastGavItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = lastGavItem.lastIndexOf(DuplicateClassConstants.COMMA_STR);</span><br><span class="line">        <span class="keyword">return</span> lastGavItem.substring(<span class="number">0</span>, lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printDuplicateClassInfo</span><span class="params">(Consumer&lt;String&gt; consumer, String classItem, Set&lt;String&gt; artifactIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String title = DuplicateClassConstants.LOG_TAG + <span class="string">"class["</span> + classItem + <span class="string">"] exist in following artifact:"</span>;</span><br><span class="line">        consumer.accept(title);</span><br><span class="line">        <span class="keyword">for</span> (String artifactId : artifactIds) &#123;</span><br><span class="line">            <span class="keyword">final</span> String content = <span class="string">"------------&gt;: "</span> + artifactId;</span><br><span class="line">            consumer.accept(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li>FileRetriever.java文件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRetriever</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassesFromPath</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getClassesFromDirectory(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getClassesFromJarFile(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 'com/demo/DuplicateClassFoundMojo' 转换成 "com.demo.DuplicateClassFoundMojo"</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">fromFileToClassName</span><span class="params">(<span class="keyword">final</span> String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileName.replaceAll(<span class="string">"[/\\\\]"</span>, <span class="string">"\\."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassesFromJarFile</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (path.canRead()) &#123;</span><br><span class="line">                List&lt;String&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                JarFile jar = <span class="keyword">new</span> JarFile(path);</span><br><span class="line">                Enumeration&lt;JarEntry&gt; en = jar.entries();</span><br><span class="line">                <span class="keyword">while</span> (en.hasMoreElements()) &#123;</span><br><span class="line">                    JarEntry entry = en.nextElement();</span><br><span class="line">                    <span class="keyword">final</span> String name = entry.getName();</span><br><span class="line">                    <span class="keyword">if</span> (name.endsWith(DuplicateClassConstants.CLASS_FILE_SUFFIX) &amp;&amp; !name.endsWith(DuplicateClassConstants.MODULE_INFO_CLASS_SUFFIX)) &#123;</span><br><span class="line">                        String className = fromFileToClassName(name);</span><br><span class="line">                        classes.add(className);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> classes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(DuplicateClassConstants.LOG_TAG + <span class="string">"Failed to read classes from jar file: "</span> + path, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassesFromDirectory</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// get jar files from top-level directory</span></span><br><span class="line">        List&lt;File&gt; jarFiles = listFiles(path, (dir, name) -&gt; name.endsWith(DuplicateClassConstants.JAR_FILE_SUFFIX), <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (File file : jarFiles) &#123;</span><br><span class="line">            classes.addAll(getClassesFromJarFile(file));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get all class-files</span></span><br><span class="line">        List&lt;File&gt; classFiles = listFiles(path, (dir, name) -&gt; name.endsWith(DuplicateClassConstants.CLASS_FILE_SUFFIX), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> substringBeginIndex = path.getAbsolutePath().length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (File classfile : classFiles) &#123;</span><br><span class="line">            String className = classfile.getAbsolutePath().substring(substringBeginIndex);</span><br><span class="line">            className = fromFileToClassName(className);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classes.add(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">listFiles</span><span class="params">(File directory, FilenameFilter filter, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        File[] entries = directory.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (entries == <span class="keyword">null</span> || entries.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Go over entries</span></span><br><span class="line">        <span class="keyword">for</span> (File entry : entries) &#123;</span><br><span class="line">            <span class="comment">// If there is no filter or the filter accepts the</span></span><br><span class="line">            <span class="comment">// file / directory, add it to the list</span></span><br><span class="line">            <span class="keyword">if</span> (filter == <span class="keyword">null</span> || filter.accept(directory, entry.getName())) &#123;</span><br><span class="line">                files.add(entry);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the file is a directory and the recurse flag</span></span><br><span class="line">            <span class="comment">// is set, recurse into the directory</span></span><br><span class="line">            <span class="keyword">if</span> (recurse &amp;&amp; entry.isDirectory()) &#123;</span><br><span class="line">                files.addAll(listFiles(entry, filter, <span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Return collection of files</span></span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>
<br>



]]></content>
      <categories>
        <category>maven</category>
        <category>plugin</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>《kafka权威指南》- 读书笔记</title>
    <url>/2020/08/15/%E3%80%8Akafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a name="ZazXK"></a></p>
<h2 id="chapter-2-安装"><a href="#chapter-2-安装" class="headerlink" title="chapter 2-安装"></a>chapter 2-安装</h2><p><a name="nbCIi"></a></p>
<h3 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1. zookeeper"></a>1. zookeeper</h3><ul>
<li>zk的作用: 存储消费者信息+topic信息+kafka集群的信息</li>
<li>zk集群会有选举，所以节点数量最好是奇数以免形成脑裂. 但一个zk集群不建议包含超过7个节点，因为节点过多时在进行集群一致性统一时，会消耗过多资源造成整体集群的性能下降</li>
<li>zk的几个端口<ul>
<li>clientPort: 客户端连接到zk集群所用的端口，默认是2181</li>
<li>peerPort: 节点与节点之间平时进行数据通信时所用的TCP端口</li>
<li>leaderPort: 用于集群选举时通信用的TCP端口</li>
</ul>
</li>
</ul>
<br>

<p><a name="zaS5H"></a></p>
<h3 id="2-kafka-broker配置"><a href="#2-kafka-broker配置" class="headerlink" title="2. kafka broker配置"></a>2. kafka broker配置</h3><ul>
<li>port: kafka服务端开放给客户端连接的端口, 默认是9092</li>
<li>brokder.id:当前broker在kafka集群中的唯一编号</li>
<li>zookeeper.connect: zk的地址，这里的zk就是上面说的用于存储kafka集群信息+topic信息+消费者信息的</li>
<li>log.dirs: 存放数据的目录。 kafka的消息都存放在这些目录中，该参数是一组以逗号隔开的文件系统路径。当有多个文件系统路径时，Kafka存放消息的时候会往最空闲(存的数据最少)的目录上放</li>
<li>num.recovery.threads.per.data.dir: broker服务器启动/关闭时，每个log.dir 会有多少个线程去处理里面的数据</li>
<li>auto.create.topics.enabe: 当topic不存在的时候是否会默认生成？ 该配置默认是true</li>
</ul>
<p><a name="VUATP"></a></p>
<h3 id="3-kafka-topic的配置"><a href="#3-kafka-topic的配置" class="headerlink" title="3. kafka topic的配置"></a>3. kafka topic的配置</h3><ul>
<li>num.partitions</li>
<li>消息存留策略<ul>
<li>log.retention.ms</li>
<li>log.retention.bytes</li>
</ul>
</li>
<li>日志片段关闭的策略: 当一个日志片段关闭之后，新的日志片段才会生成<ul>
<li>log.segment.bytes. 关闭某个segment的最小bytes，当一个topic一天只能收到1M的数据，而该参数设置的值是10M，那么需要10天才能达到阀值。这10天内该segment是不会过期的. 如果log.rention.ms的值是7天，那么一个segment的生命周期就是10+7=17天</li>
<li>log.segment.ms: 关闭某个segment的最小ms数</li>
</ul>
</li>
<li>message.max.bytes: 单个消息的最大byte数. 默认是1M<ul>
<li>该值指的是压缩后消息大小</li>
<li>如果生产者发送超过该大小的消息，broker不会处理该消息，同时会返回错误信息</li>
</ul>
</li>
</ul>
<br>

<p><a name="W28mb"></a></p>
<h3 id="4-硬件选择的影响"><a href="#4-硬件选择的影响" class="headerlink" title="4. 硬件选择的影响"></a>4. 硬件选择的影响</h3><ul>
<li>对生产者的影响<ul>
<li>磁盘的吞吐量. 吞吐量越大，数据写入速度就越快，生产者生产消息的时候的延时就越低</li>
<li>磁盘容量。越大就能存越多的数据</li>
</ul>
</li>
<li>对消费者的影响<ul>
<li>内存: 当读取消息的时候，会将消息读取到broker的内存中，所以内存会影响消费者的读取速度. 一般建议不要跟其他应用公用一个内存，即最好kafa服务器中没有其他的应用程序在一起跑</li>
</ul>
</li>
<li>对生产者/消费者都有影响<ul>
<li>网络: 如果集群的网络带宽被沾满，那么写入数据/读取数据都会收到影响，同时集群内的数据复制也会占用带宽，这样就会造成性能很差的表象</li>
<li>CPU: 消息的传递需要压缩/解压缩，所以会消耗较多的CPU。 但是CPU对kafka的影响还是比较小的</li>
</ul>
</li>
</ul>
<br>

<p><a name="JEcX4"></a></p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><ul>
<li>集群中broker的配置<ul>
<li>大家指向的zk地址是同一个，这样才能通过zk来统一管理</li>
<li>broker.id在集群内是唯一的。如果有两个broker.id是一样的，那么会有一个无法启动</li>
</ul>
</li>
<li>数据中心布局<ul>
<li>kafka集群虽然会有备份的说法，但是如果备份的数据跟主数据在同一个机房上，一旦机房出现故障，数据就会丢失，起不到备份的作用。所以最好是不同的机房+不同的机架进行数据备份</li>
</ul>
</li>
<li>对于zookeeper<ul>
<li>存储kafak集群信息+消费者元数据+topic数据</li>
<li>在kafka 0.9.0.0之后，消费者元数据信息已经放到了broker中. 这样就减少了zk的压力</li>
<li>最好zk集群不要跟其他应用程序一起使用，以免相互污染</li>
</ul>
</li>
</ul>
<br>

<p><a name="6UHdR"></a></p>
<h2 id="kafka-producer"><a href="#kafka-producer" class="headerlink" title="kafka producer"></a>kafka producer</h2><p>kafka producer包含以下几个信息</p>
<ul>
<li>topic</li>
<li>partition</li>
<li>key</li>
<li>value</li>
</ul>
<p><br>在发送一个消息的时候，producer会对消息进行</p>
<ul>
<li>通过key进行分区计算，得出当前消息应该去哪个区。这就是分区器</li>
<li>对key/value进行序列化，这就是序列化器。当然在consumer拿到数据的时候会进行反序列化</li>
<li>以上两个都可以自定义</li>
</ul>
<br>
<br>在创建一个producer的时候，我们需要指定

<ul>
<li>bootstrap.servers: broker集群中的某几个broker的地址清单，以 host:port 形式给出。需要注意的是不一定需要将所有的broker地址都列出来，只要给出一两个即可。producer可以通过其中一个找到其他的broker。但是清单中的最好大于等于2个，以免一个broker挂了可以通过另一个去找到broker集群</li>
<li>key.serializer</li>
<li>value.serializer</li>
</ul>
<br>
<br>producer的一些配置

<ul>
<li>acks: 有多少个broker回应了成功，这一次写数据才算成功？ 0表示不用broker恢复，扔完消息就不管了; 1表示只要有一个就可以，这里的1个一般都是leader broker; 当需要所有broker都回复了，可将该值设置为all，这也是最安全的方式，但是也是最耗时的</li>
<li>compression.type: 对消息的压缩。默认是没有的</li>
<li>retries: 失败重试的次数。有时候失败是由于broker集群刚好在换届选举，此时重试下成功的概率将很大。kafka默认是会重试的</li>
<li>缓冲相关的配置<ul>
<li>buffer.memory: 当往服务器发送消息，被堵住时，producer所在机器最多可以缓冲多少接下来想要发送的消息而不报错.</li>
<li>batch.size： 一个批次的数据大小, 到了这个值就会出发一次网络IO。但需要注意的是并不是每次都要达到该值才会触发网络传输，有时候达到一半就会触发，这跟linger.ms有关。kafka producer并不会每来一个消息就发送，而是会等到有一定量的时候才一次将消息发送到brokder，这样可以减少网络传输，最大化效率</li>
<li>linger.ms: 发送批次之前，等待多长时间</li>
<li>max.block.ms: 当producer的发送缓冲区已经满了，即buffer.memory已经达到了设置的值，或者获取不到元数据信息了(存储的时候存储不下了)，此时会等待max.block.ms时间，当时间到了就抛异常</li>
</ul>
</li>
<li>通信相关<ul>
<li>max.request.size: 一次请求所包含的最大的消息的大小. 该消息可以是一个消息，也可以是由多个消息组成。比如该值为1M，那么可以一次请求可以传输一个1M的消息，也可以传输10个1KB的消息</li>
<li>max.in.flight.request.per.connection: producer发送消息之后在收到服务器回应之前可以发送多少个消息。值越大占用producer所在机器的内存越大，当然吞吐量也越大。当该值为1时，能保证消息的顺序</li>
</ul>
</li>
</ul>
<br>
<br>关于分区

<ul>
<li>如果消息的key为null，那么将会使用默认的分区器，此时会采用round robin(轮询)的方式，随机将消息投递到某个分区</li>
<li>如果消息的key不为null，并且没有指定分区器，则也会使用默认的分区器，此时<ul>
<li>对key进行hash云端，得到一个值</li>
<li>然后将这个值映射到broker集群下的某个分区。这里需要注意的是<ul>
<li>只要集群没有新增分区，那么该key会被一直分配到同一个broker；但当分区新增了，那就会投到别的分区了</li>
<li>会将集群下的所有分区都拿过来进行映射，无论该分区是否可用。如果选中的那个分区不可用，那么会报错。这也解释了为什么是增加分区，而不是说加少分区会对映射结果有影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<br>

<p><a name="sa4Cv"></a></p>
<h2 id="chapter-4-consumer"><a href="#chapter-4-consumer" class="headerlink" title="chapter 4 - consumer"></a>chapter 4 - consumer</h2><p><br>一个topic的消费者群组中的consumer个数需要比该topic内的分区数少，否则会出现某些consumer没有partition可处理，造成资源闲置<br><br><br>消费者获取数据，是通过主动拉取的方式获取的，调用的是 consumer.poll方法. 在调用该方法时，会做好多事情，包括</p>
<ul>
<li>将自己加入到 consumer group中</li>
<li>给群组协调器的broker发送心跳，告诉它我还活着</li>
<li>提交上一次的处理完的消息的偏移量 (在自动提交的时候)</li>
</ul>
<br>

<p><a name="URXV7"></a></p>
<h3 id="1-再分配"><a href="#1-再分配" class="headerlink" title="1. 再分配"></a>1. 再分配</h3><ul>
<li>当群组中有新的consumer加进来或者有consumer死去，那么consumer group就会对分区做再分配的动作, 即topic的分区所有权可能会从consumer1转移到其他consumer上</li>
<li>实现过程:<ul>
<li>第一个加入群组的consumer会成为群主</li>
<li>群主会从 协调器broker中获取当前群主的所有 consumer信息</li>
<li>然后群主根据一定的策略，给每个consumer分配它需要处理的partition。策略目前有两个<ul>
<li>range: 该策略可能会出现某个consumer明显多，某个consumer明显少的情况</li>
<li>roundRobin: 轮询分配，该分配策略分配的比较平均</li>
</ul>
</li>
<li>最后群主会将分配情况提交给 协调器broker; 然后协调器broker会给每个consumer发送它自己分配到的partition。这样，只有群主知道其他consumer的partition分配情况；而其他的consumer只知道自己分配到的partition情况，看不到其他人的</li>
</ul>
</li>
<li>再分配期间，整个群组将不可用，即不能消费消息</li>
</ul>
<br>
<br>在实践中，推荐一个consumer一个线程，不要一个线程里有多个consumer；这样做到互不相干，不会互相影响。<br>
<br>

<p><a name="SrmEB"></a></p>
<h3 id="2-消费者的一些参数配置"><a href="#2-消费者的一些参数配置" class="headerlink" title="2. 消费者的一些参数配置"></a>2. 消费者的一些参数配置</h3><ul>
<li>一次能获取到的数据<ul>
<li>max.partition.fetch.bytes ： 代表consumer一次能从每个partition中获取到的消息的最大字节数。该值不能小于topic配置中的 max.message.size. 否则会造成消费者获取不到数据，从而一直在重试</li>
<li>fetch.min.bytes: 一次拿到的数据的最小字节数。少于该值将会等待，这有助于减少网络IO次数</li>
<li>fetch.max.wait.ms： 该参数表示在拿不到fetch.min.bytes数量的字节数的情况下，等待多久就返回。</li>
</ul>
</li>
<li>偏移量相关<ul>
<li>auto.offset.reset: 消费者在读取一个没有偏移量的分区或者该偏移量无效的时候应该怎么办？<ul>
<li>默认值是latest，表示从最新的记录开始读取；</li>
<li>还有一个值是earliest，表示从起始位置开始读取数据</li>
</ul>
</li>
<li>enable.auto.commit: 是否自动提交偏移量。默认是true. 并且默认的间隔时间是5s.</li>
</ul>
</li>
</ul>
<br>

<p><a name="xSkTX"></a></p>
<h3 id="3-偏移量-amp-提交"><a href="#3-偏移量-amp-提交" class="headerlink" title="3. 偏移量&amp;提交"></a>3. 偏移量&amp;提交</h3><ul>
<li>实现机制: 偏移量的提交，是消费者往一个叫做 “_consumer_offset”的特殊topic发送消息，记录自己消费的偏移量信息。</li>
<li>提交方式<ul>
<li>自动提交: 使用kafka默认的机制提交。但这个策略容易造成消息的重复消费，因为两次提交之间的间隔内可能发生再均衡了</li>
<li>手动提交，能更精确的控制<ul>
<li>同步提交: 比较安全，但是会堵塞住处理线程，降低吞吐量</li>
<li>异步提交: 能快速提交，并且借助回调函数能知道成功与否. 但会出现时间上是前面提交的偏移量，但是却是更后面达到，从而会有覆盖的现象. 比如11:30提交了2000的偏移量，但是发生了短暂的通信问题，导致服务器收不到；与此同时我们处理了另外一批数据，并成功提交了偏移量3000。如果我们进行重试，那么偏移量为2000的可能会覆盖偏移量3000</li>
<li>同步+异步提交: 处理的时候通过异步方式实现，这样快速；一旦出现异常时(比如网络不稳定)，则使用同步做补偿，由于同步会一直重试直至成功或者发生无法恢复的错误才会停止，所以同步能确保最后处理的偏移量能提交成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>其他<ul>
<li>我们可以监听 再均衡事件，对其进行处理. 方式是: 在consumer.subscribe(topic, listener)</li>
<li>我们也可以通过 seek的方式，从我们想要的偏移量位置上开始处理数据。这在数据丢失或者重复的时候，比较有用</li>
<li>在程序关闭的时候，可以通过在ShutdownHook调用 consumer.wakeup方法让 consumer.poll 抛出异常，然后在finally中调用consumer.close对 消费者占用的资源做清理</li>
</ul>
</li>
</ul>
<br>

<p><a name="8RBdk"></a></p>
<h2 id="chapter-5-深入Kafka"><a href="#chapter-5-深入Kafka" class="headerlink" title="chapter 5 - 深入Kafka"></a>chapter 5 - 深入Kafka</h2><p><a name="SZLjE"></a></p>
<h3 id="broker集群"><a href="#broker集群" class="headerlink" title="broker集群"></a>broker集群</h3><p><a name="R6OV9"></a></p>
<h4 id="1-集群成员关系"><a href="#1-集群成员关系" class="headerlink" title="1.集群成员关系"></a>1.集群成员关系</h4><p>一个独立运行的kafka服务器，被称为broker。多个broker配置的zk信息是同一个，那么它们就会形成一个kafka集群</p>
<ul>
<li>每个broker注册到集群的时候，都是以一个zk临时节点的形式出现的，它们会被挂载到目录<code>brokers/ids</code>下面</li>
<li>每个broker都会有一个id. 如果它的id已经有其他bro ke r在用了，那么它会启动失败</li>
<li>当一个broker失联了，那么它对应的zk临时节点会被移除</li>
</ul>
<p><a name="CEU5r"></a></p>
<h4 id="2-控制器broker"><a href="#2-控制器broker" class="headerlink" title="2.控制器broker"></a>2.控制器broker</h4><p>一个topic会有多个分区，每个分区会落到一个broker上. 同时每个分区又会有多个副本，以做灾备之用. 所以这时候对于每个分区而言，就需要选举一个leader分区来，这样该分区的副本分区就会从leader分区复制数据。这个leader分区的选举工作是由一个叫做 控制器(controller)的broker来负责的。<br><br><br>控制器broker具有以下特点</p>
<ul>
<li>控制器broker本质上也是一个broker，所以它具有普通broker的功能. </li>
<li>控制器broker还负责分区的选举工作，这是它特有的功能</li>
</ul>
<p><br>控制器broker选举过程: </p>
<ul>
<li>集群中的每个broker在启动的时候，都会去zk上注册一个名叫 <code>/controller</code>的节点，以让自己成为控制器broker</li>
<li>当发现该节点已经存在的时候，就知道控制器broker已经名花有主了. 当前的broker就会去watch 该节点，这样就可以收到该节点的变更信息. </li>
<li>每个controller都有自己的任期(也叫纪元)，该值通过epoch来表示</li>
<li>当控制器broker挂了的时候，其他节点会收到通知，然后就会尝试去争当controller. 当一个新的节点成为了controller之后，它的epoch会比之前的大；</li>
<li>通过epoch，即使前任controller重新连接到集群里来，也无法成为controller了，因为那些普通broker知道自己的controller当前的epoch是多少，当收到小于该epoch的消息，它们会忽略</li>
</ul>
<br>

<p><a name="HxLmq"></a></p>
<h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h4><p>复制就是副本分区从leader分区copy数据的过程. 这个过程是顺序执行的，即副本分区在请求消息5的时候，它肯定已经完成了消息1/消息2/消息3/消息4的复制<br><br><br>跟leader分区的数据保持一致的分区，被称作同步副本。在首领失踪时，这些副本是有可能被选为新首领的，因为它们拥有的消息是最新的。<br>在选举谁是leader分区时，有一个首选首领的概念。 首选首领，是在分区创建的时候被选中的首领，也就是初代首领。当在某轮选举之后，首领不是首选首领，并且此时首选首领是同步副本，那么会触发选举，让首选首领成为首领。这么做的原因是，首领的负载是比较高的，一般初代首领能承受该压力(一般来说它的配置会好一些)，这样集群内的负载能达到均衡，不至于使负载能力不够高的broker负重过高，造成整体集群的不稳定。<br><br><br><br><br></p>
<p><a name="JzHEs"></a></p>
<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><p>kafka的所有消息，都是标准的，都会包含:</p>
<ul>
<li>request type - 请求类型</li>
<li>request version - 请求的版本，这在客户端版本不一致时有用. </li>
<li>correlation id - 请求消息的唯一标识，在问题诊断时用处较大</li>
<li>client id - 用于表示请求的客户端</li>
</ul>
<br>
<br>

<p><a name="si0iv"></a></p>
<h4 id="1-请求的处理过程"><a href="#1-请求的处理过程" class="headerlink" title="1. 请求的处理过程"></a>1. 请求的处理过程</h4><ol>
<li>broker会在它所监听的每个端口上创建一个Acceptor线程。该线程会创建一个链接，并将该链接交给Processor线程去处理。Processor线程也叫做网络线程</li>
<li>当请求过来的时候，processor线程会将请求放到一个请求队列中</li>
<li>然后I/O线程就会从请求队列中获取数据，进行处理；处理完之后将结果放到响应队列中，然后再通过processor线程传送回客户端</li>
</ol>
<br>

<p><a name="zzdrp"></a></p>
<h4 id="2-请求种类"><a href="#2-请求种类" class="headerlink" title="2. 请求种类"></a>2. 请求种类</h4><p><a name="dELMg"></a></p>
<h5 id="2-1-元数据请求"><a href="#2-1-元数据请求" class="headerlink" title="2.1.元数据请求"></a>2.1.元数据请求</h5><p>所谓元数据就是包含topic有哪些分区，分区的副本信息，分区的首领是谁等信息。客户端通过该信息可以知道将请求发送到哪个broker(这里就是首领分区所在的broker)。客户端会缓存元数据，那么它如何保证自己的元数据是罪行的呢？</p>
<ul>
<li>topic内的所有broker的元数据信息都是一样的</li>
<li>当请求的时候，目标broker不是首领broker，那么目标broker会将当前最新的元数据信息返回给客户端。 客户端收到之后就知道自己的元数据信息已经过时了，会做更新并将请求发送到leader broker上去</li>
<li>同时客户端会定时的主动请求元数据信息，以使自己不落伍</li>
</ul>
<br>

<p><a name="zbS6X"></a></p>
<h5 id="2-2-生产请求"><a href="#2-2-生产请求" class="headerlink" title="2.2.生产请求"></a>2.2.生产请求</h5><p>生产请求，主要有一个acks参数. 该参数表示有多少的副本拥有了该消息才算成功. 该参数有三个值</p>
<ul>
<li>0, 表示不用复制，发出去就收工. 不用管是否到达</li>
<li>1。表示只要leader broker收到就可以了</li>
<li>all，表示分区内的所有副本都需要成功收到该消息才做发送成功</li>
</ul>
<p><br>需要注意的是: broker在收到消息的时候，是将消息写入操作系统的缓存中的，此时并没有写入到磁盘中. 何时写入磁盘取决于操纵系统<br><br><br></p>
<p><a name="isQNl"></a></p>
<h5 id="2-3-读取请求"><a href="#2-3-读取请求" class="headerlink" title="2.3.读取请求"></a>2.3.读取请求</h5><p>读取的时候有两个重要参数:</p>
<ul>
<li>限制broker最多可以从一个分区返回多少的数据；这个参数可以防止分区返回过多的数据，造成消费端的内存不够的现象</li>
<li>等待多久之后如果分区还是没有那么多数据，就返回；这个参数防止broker生产的数据太少，等待太久</li>
</ul>
<p><br>同时需要注意的是，当生产者在生产数据的时候，该数据的副本数没有达到acks的数量时，consumer是读取不到该消息的。因为假如可以读取到，当leader broker突然挂了，此时acks的数量还不够，那么新的leader broker很可能就没有那条消息，这就会造成再次读取的时候发现读取不到那条消息了，从而导致数据的不一致<br><br><br></p>
<p><a name="CFmss"></a></p>
<h5 id="2-4-其他请求"><a href="#2-4-其他请求" class="headerlink" title="2.4.其他请求"></a>2.4.其他请求</h5><p>由于kafka的消息是使用标准的协议进行流转的，所以kafka可以实现跨语言的交流。即java客户端可以读取到go客户端生产的数据。<br>关于客户端跟服务器(即broker)之间的版本升级的问题，需要注意的是: 一定是先升级服务端，然后再升级客户端。</p>
<ul>
<li>因为客户端发送请求的时候，会指定自己当前是什么版本。如果该版本在服务端是不支持的，那么服务端将不知道如何处理。反过来则可以处理</li>
</ul>
<br>

<p><a name="kUkAq"></a></p>
<h3 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h3><p><a name="OykGr"></a></p>
<h4 id="1-分区分配规则"><a href="#1-分区分配规则" class="headerlink" title="1. 分区分配规则"></a>1. 分区分配规则</h4><p>分区是kafka最基本的存储单元了，所以在进行分区分配的时候，应尽量做到容灾</p>
<ul>
<li>分布均匀的分配在不同的broker中</li>
<li>同一个分区的不同副本尽量不要放在同一个broker. 防止一个broker挂了，数据丢失</li>
<li>如果有条件搞多机房多机架，那么也要将分区的副本分不到不同的机房机架上去</li>
</ul>
<br>

<p><a name="ddzUg"></a></p>
<h4 id="2-segment与句柄"><a href="#2-segment与句柄" class="headerlink" title="2. segment与句柄"></a>2. segment与句柄</h4><p>由于在一个大文件里查找和删除都是很费时且容易出错的，所以kafka把分区分成多个片段(segment). 默认情况下，每个片段包含1GB或者一周的数据，以较小者为准。在写入数据的时候，如果一个片段达到它的上限，那么他会被关闭，然后开启一个新的segment来处理数据。<br>这里需要注意的是，操作系统会为每个片段都打开一个句柄，即使该片段不活跃。这样就会造成操作系统的句柄会被快速地用光，所以可以根据实际情况对操作系统做一定的调优。<br><br><br></p>
<p><a name="J3C60"></a></p>
<h4 id="3-零复制技术"><a href="#3-零复制技术" class="headerlink" title="3. 零复制技术"></a>3. 零复制技术</h4><p>kafka的消息在网络传输，磁盘上保存，都是同样的数据格式。这个特性可以使数据在读取的时候实现零复制，即直接从文件系统中将消息读取出来，然后直接返回给客户端，而不需要在broker的内存中进行复制解压打包等工作，从而不需要在broker上分配额外的内存去处理。 consumer端拿到数据之后，按照格式进行解压处理即可<br><br><br>这里有个需要注意的地方，就是如果任意一端对数据格式的改动，其他各端都需要跟着改，否则数据就不能兼容处理了。 比如生产端加了某些东西，那么consumer侧也需要做处理，否则将处理不了新数据<br><br><br><br><br></p>
<p><a name="hLZie"></a></p>
<h4 id="4-索引"><a href="#4-索引" class="headerlink" title="4. 索引"></a>4. 索引</h4><p>kafak为每个分区都维护了一个索引，以快速读取数据。该索引维护的是消息的偏移量跟片段文件的关系，以及偏移量在片段文件内的位置<br><br><br></p>
<p><a name="jz2IL"></a></p>
<h4 id="4-清理"><a href="#4-清理" class="headerlink" title="4. 清理"></a>4. 清理</h4><p>当数据重复或者存在脏数据时，需要对数据进行清理。可通过参数 log.cleaner.enabled 来开启清理工作。每个日志片段的数据，都可以分成两部分:</p>
<ul>
<li>干净的部分，这部分数据是上一次清理之后留下来的</li>
<li>污浊的部分，这部分数据是上一次清理之后产生的</li>
</ul>
<p>清理的大致步骤如下</p>
<ol>
<li>在内存中生成一个map，将污浊部分的数据写入该map，key为消息的键的hash值，value为消息的偏移量</li>
<li>由于是从污浊部分数据的开头开始遍历写的，所以如果某个key在污浊数据内存在多次，那么最后一次的数据将保留</li>
<li>对日志片段的数据进行遍历，从干净部分的数据开始</li>
<li>如果数据在map中不存在，说明该数据是新数据，移到替换的片段上</li>
<li>如果数据在map中存在，说明该数据在污浊部分是存在的，则丢弃当前的</li>
<li>然后将map中的数据，移到替换片段上</li>
<li>最后将替换片段与原始片段交换，从而实现数据的清理</li>
</ol>
<br>
<br>墓碑消息: key存在，但是其value为null的消息

<p><a name="c236ec07"></a></p>
<h2 id="chapter-6-可靠的数据保证"><a href="#chapter-6-可靠的数据保证" class="headerlink" title="chapter 6 - 可靠的数据保证"></a>chapter 6 - 可靠的数据保证</h2><p><br>kafka的数据可靠性是通过复制和分区的多副本来保证的。kafka的topic保存在多个分区中，每个分区可以有多个副本，每个副本对应一个broker。所以每个分区都有一个leader，用来对外接受/处理事件，其他的broker则是follower。follower会定时的同步leader的信息，以此来保证自己是同步副本<br><br><br>同步副本需要满足以下条件</p>
<ul>
<li>过去6s内向zookeeper发送过心跳</li>
<li>过去10s从leader那里获取过消息</li>
<li>过去10s从leader那里获取过最新的消息. 光从首领那里获取消息是不够，还必须是最新的消息</li>
</ul>
<p><br>可以通过kafka的几个重要组建的配置来做一些保证<br></p>
<p><a name="38c860c1"></a></p>
<h3 id="1-broker的配置"><a href="#1-broker的配置" class="headerlink" title="1. broker的配置"></a>1. broker的配置</h3><table>
<thead>
<tr>
<th>参数</th>
<th>配置项</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><a name="AJtbN"></a></p>
<h4 id="1-1-复制参数"><a href="#1-1-复制参数" class="headerlink" title="1.1. 复制参数"></a>1.1. 复制参数</h4><p>该参数表示需要多少个副本，可以在topic层级进行配置，也可以在broker层面配置</p>
<ul>
<li>topic级别的参数: replication.factor </li>
<li>broker层级的参数: default.replication.factor - 表示自动创建的主题的将会有多少个副本</li>
</ul>
<p>该值越大可靠性越高，单会消耗过多的资源; 该值越小则可靠性不可保障<br></p>
<p><a name="PHrM4"></a></p>
<h4 id="1-2-不完全首领选举"><a href="#1-2-不完全首领选举" class="headerlink" title="1.2. 不完全首领选举"></a>1.2. 不完全首领选举</h4><p>该参数是broker级别(实际上是集群范围内，因为只有broker集群才有选举)的，用于当首领处于不可用的时候，是否可以将非同步副本选举为首领。参数名为: unclean.leader.election, 默认为true</p>
<ul>
<li>如果允许则需要忍受消息丢失的问题</li>
<li>如果不允许，则需要忍受不可用的情况(首领不可用，其他副本又都不是同步副本，那就只能等首领重新活过来了)</li>
</ul>
<p><a name="e6b31b40"></a></p>
<h4 id="1-3-最少同步副本"><a href="#1-3-最少同步副本" class="headerlink" title="1.3. 最少同步副本"></a>1.3. 最少同步副本</h4><p>该参数表示kafka写消息的时候，需要多少个副本的确认才认为该消息写入成功。当broker集群中的同步副本少于该配置值时，写消息将失败，此时集群只能提供读功能。这是一个可靠性跟可用性之间的一个权衡<br>在broker跟topic上都可以配置该参数，并且它们都叫: min.insync.replicas<br><br><br></p>
<p><a name="QdXNv"></a></p>
<h3 id="2-producer"><a href="#2-producer" class="headerlink" title="2. producer"></a>2. producer</h3><p>生产者在写入消息的时候，很重要的一个参数是acks，表示需要有多少个副本的确认才认为是成功的。同时在写入消息时可能发生错误，此时可以通过重试来提供成功率。但这里需要注意的是并不是所有的错误都是可以重试的</p>
<ul>
<li>可重试的错误，一般是网络问题或者 broker集群在选举返回LEADER_NOT_AVAILABLE</li>
<li>不可重试的错误，一般是配置错误导致的，比如INVALID_CONFIG这种错误</li>
</ul>
<p><br>重试带来的风险是，数据可能会重复写入。此时最好在消息中带上一个唯一ID，以方便自己或者consumer做幂等处理<br><br><br></p>
<p><a name="YshaY"></a></p>
<h3 id="3-consumer"><a href="#3-consumer" class="headerlink" title="3. consumer"></a>3. consumer</h3><p>消费者读取消息都是根据偏移量来进行的，所以如果提交了偏移量但是没有处理完消息就挂了，那么“其他”消费者过来顶替的时候，之前那条消息则永远不会被消费，因为偏移量已经提交了。所以一般都是在处理完了消息之后再进行偏移量的提交的，也正因为该原因，一般都是显式提交偏移量。显式提交偏移量，可能需要注意</p>
<ul>
<li>在消费消息的时候，如果失败了，可以将该消息写入其他地方或者写入一个专门的topic，稍后再处理。这样可以保证后面的消息可以正常得到处理，而不影响总体进度</li>
<li>如果消息过大，或者处理的时候需要做一些IO等操作，可以通过使用线程池来来提高吞吐量</li>
<li>有时候我们需要消费不只是”at least once” 而是”exactly once”，此时就可以借助其他系统来保证了，比如借助DB的唯一主键来达到幂等消费</li>
</ul>
<br>

<p><a name="b6cda125"></a></p>
<h2 id="chapter-11-流式处理"><a href="#chapter-11-流式处理" class="headerlink" title="chapter 11 - 流式处理"></a>chapter 11 - 流式处理</h2><p>事件流，也叫数据流，是一种无边界的事件集合的抽象表示. 在该流中，事件会源源不断的产生，然后被处理，Java 8中的stream就是这么一个东西。事件流除了无边界外，还有其他一些特性</p>
<ul>
<li>有序性。事件的发生总是有时间的先后顺序的</li>
<li>数据不可变性。只要生成了，就不会改变，就像MySQL的binlog记录数据库的所有操作一样</li>
<li>可重播性. 对历史事件流可以重播，比如重播发生在几个月前的数据，而这也是事件流的一个较大的特性</li>
</ul>
<br>
<br>流式处理是指实地处理一个或多个事件流，跟Request-Response，批处理一样，流式处理也是一种编程范式

<ul>
<li>request-response: 大部分的请求都是该类型，比如在页面上查询某个商品的价格，请求之后就等在那里，知道有响应返回或者超时. 该范式的特点是: 数据量小，响应时间快</li>
<li>批处理，是指对数据进行批量处理，比如对一堆数据进行处理然后生成报表供老板看。这种一般都是对冷数据的处理，数据量比较大耗时较严重，不会要求有很高的实时性。</li>
<li>流式处理，则是介于上面两者之间. 它既不需要响应很及时，但是又不是说过个几个小时才有响应. 同时它一次处理的数据不会非常大，但也不小</li>
</ul>
<br>
<br>

<p><a name="R3gXy"></a></p>
<h3 id="流式处理的一些概念"><a href="#流式处理的一些概念" class="headerlink" title="流式处理的一些概念"></a>流式处理的一些概念</h3><ul>
<li>时间. 流式处理中有三个时间<ul>
<li>事件时间，该时间是事件发生的时间</li>
<li>日志追加时间. 改时间是事件被存储到某个地方的事件，比如kafka中则是存入到broker中</li>
<li>处理时间，该时间则是事件被处理的事件. 这个时间不是很准确，比如事件被两个线程处理了，那么它就会有两个处理时间</li>
</ul>
</li>
<li>状态. 事件跟事件之间的信息被称为状态，一般是事件与事件之间有关联性时会用上。状态的类型有<ul>
<li>本地状态/内部状态. 该状态存储在应用实例的本地，不能被别的实例所看到</li>
<li>外部状态，该状态是可以在各个实例间共享，一般是通过外部数据存储来维护. 尽量避免这类状态，因为这个很影响流处理过程的时延</li>
</ul>
</li>
<li>流跟表的关系.<ul>
<li>流包含数据的每个变更</li>
<li>表，只包含数据的最新状态.</li>
</ul>
</li>
<li>时间窗口，大部分流式处理都是基于事件窗口的，时间窗口在选择上需要注意几点<ul>
<li>窗口的大小. 窗口越小，就能越快地发现变更，但是噪音也越多. 窗口越大，变更发现的越慢，但是对应的变更越平滑准确</li>
<li>窗口移动的频率<ul>
<li>当移动间隔的时间跟窗口的大小刚好相等时，这种窗口被认为滚动窗口. 两个窗口之间是刚好衔接，没有任何的重叠或者间隙</li>
<li>当有事件发生就移动一次，这种认为是滑动窗口。两个窗口之间会有重叠</li>
</ul>
</li>
<li>窗口可更新的时长，该问题主要对于延迟比较严重的事件到来时应该如何处理. 比如10:00-11:00之间的事件已经处理过了，但是在15:30时收到了一个发生在 10:00-11:00之间的事件，那么需不需要处理呢？对于这种情况可以定义个时间范围，比如只接受1小时的时间偏差的时间，当超过该范围的事件直接忽略</li>
</ul>
</li>
</ul>
<br>

<p><a name="ZD60j"></a></p>
<h3 id="流式处理的设计模式"><a href="#流式处理的设计模式" class="headerlink" title="流式处理的设计模式"></a>流式处理的设计模式</h3><p>流式处理的设计模式大概有以下几种</p>
<ul>
<li>单事件处理模式</li>
<li>使用本地状态</li>
<li>多阶段和重分区<ul>
<li>该类模型，一般用于需要多次处理得出一个最终结果的业务，并且每一个下游阶段相比上游阶段来说，其数据量都会少很多</li>
<li>比如对于统计每天涨跌幅度最大的前十的股票. <ul>
<li>每个实例，不可能处理所有的股票，因为数据太多，实力不允许. 所以股票会根据其代号被分配到不同的实例去处理</li>
<li>处理好之后，将该股票的涨跌幅度发送到一个只包含单分区的新主题上</li>
<li>这样新主题的分区收到的数据所包含的内容将很少，只有股票的基本信息，所以能扛住</li>
</ul>
</li>
<li>其实这就是一个map-reduce的过程</li>
</ul>
</li>
<li>使用外部查找-流表的连接<ul>
<li>这里一般是需要对流信息做一定的数据补充，该数据又存储在数据库中. 比如希望对用户的点击事件做数据丰富，将用户的一些基本信息，比如性别/年龄等信息补充上来. </li>
<li>此时不可能在流处理中去查询数据库，原因有二<ul>
<li>这样会对流式处理造成较大的时延</li>
<li>同时由于事件流的数据量是不可预估的，如果查询将会对数据库造成非常大的压力，从而会影响其他的业务</li>
</ul>
</li>
<li>所以一般的处理是，将数据缓存到本地，然后在数据库有变化时，更新缓存. 即捕捉数据库的变更并形成事件流，该过程被称为CDC (Change Data Capture)</li>
</ul>
</li>
<li>流与流的连接<ul>
<li>当需要将两个流的同一个key在同一个时间点发生的事件连接起来时，就需要使用流与流的连接. 比如希望看到用户搜索了什么并且从搜索结果中点击了什么，以更精准地建立用户画像，给用户推送相关信息. </li>
<li>处理的过程大致如下: 相同的key会被分配到同一个任务中，然后该任务就可以获取到该key的所有的事件，并做相关的处理</li>
</ul>
</li>
<li>重新处理<ul>
<li>当流式处理应用出现了bug，此时对其进行升级改进。那么对于之前处理过的数据该如何更正呢？在kafka中，每个事件都会被持久化起来. 这样当改造之后的流式应用新版本上线之后，可以<ul>
<li>将新版本的应用当作一个新的消费者群组</li>
<li>让它从输入topic的起始偏移量开始处理数据</li>
<li>检查结果流，当新版本的应用程序赶上进度时，将客户端应用程序从旧版本的流式应用切换到新版本</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<br>


]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
